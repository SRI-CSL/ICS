;;; THIS FILE IS AUTOMATICALLY GENERATED

(in-package 'pvs)

(ff:defforeign 'ics_caml_startup :entry-point '"ics_caml_startup")

(ff:def-foreign-call ics_void  ())

(ff:def-foreign-call ics_false ())

(ff:def-foreign-call ics_true  ())

(ff:def-foreign-call ics_nil   ())

(ff:def-foreign-call ics_deregister (v) :returning :void)

; var : string -> term
(ff:def-foreign-call ics_var ((x1 (* :char))))

; app : term -> term list -> term
(ff:def-foreign-call ics_app (x1 x2))

; num : q -> term
(ff:def-foreign-call ics_num (x1))

; plus : term list -> term
(ff:def-foreign-call ics_plus (x1))

; plus2 : term -> term -> term    
(ff:def-foreign-call ics_plus2 (x1 x2))

; minus : term -> term -> term
(ff:def-foreign-call ics_minus (x1 x2))

; unary_minus : term -> term
(ff:def-foreign-call ics_unary_minus (x1))

; times : term list -> term
(ff:def-foreign-call ics_times (x1))

; times2 : term -> term -> term
(ff:def-foreign-call ics_times2 (x1 x2))

; tup : term list -> term
(ff:def-foreign-call ics_tup (x1))

; proj : int -> int -> term -> term
(ff:def-foreign-call ics_proj (x1 x2 x3))

; update : term -> term -> term -> term
(ff:def-foreign-call ics_update (x1 x2 x3))

; equal : term -> term -> term
(ff:def-foreign-call ics_equal (x1 x2))

; diseq : term -> term -> term
(ff:def-foreign-call ics_diseq (x1 x2))

; lt : term -> term -> term
(ff:def-foreign-call ics_lt (x1 x2))

; le : term -> term -> term
(ff:def-foreign-call ics_le (x1 x2))

; gt : term -> term -> term
(ff:def-foreign-call ics_gt (x1 x2))

; ge : term -> term -> term
(ff:def-foreign-call ics_ge (x1 x2))

; integer_pred : term -> term
(ff:def-foreign-call ics_integer_pred (x1))

; mem : term -> term -> term
(ff:def-foreign-call ics_mem (x1 x2))

; unsigned : term -> term
(ff:def-foreign-call ics_unsigned (x1))

; ptrue : unit -> term
(ff:def-foreign-call ics_ptrue () )

; pfalse : unit -> term
(ff:def-foreign-call ics_pfalse () )

; ite : term -> term -> term -> term
(ff:def-foreign-call ics_ite (x1 x2 x3))

; forall : (string * constraints) list -> term -> term
(ff:def-foreign-call ics_forall (x1 x2))

; exists : (string * constraints) list -> term -> term
(ff:def-foreign-call ics_exists (x1 x2))

; neg : term -> term
(ff:def-foreign-call ics_neg (x1))

; and : term -> term -> term
(ff:def-foreign-call ics_and (x1 x2))

; or : term -> term -> term
(ff:def-foreign-call ics_or (x1 x2))

; xor : term -> term -> term
(ff:def-foreign-call ics_xor (x1 x2))

; implies : term -> term -> term
(ff:def-foreign-call ics_implies (x1 x2))

; equiv : term -> term -> term
(ff:def-foreign-call ics_equiv (x1 x2))

; empty_set : int -> term
(ff:def-foreign-call ics_empty_set (x1))

; full_set : int -> term
(ff:def-foreign-call ics_full_set (x1))

; setite : term -> term -> term -> term
(ff:def-foreign-call ics_setite (x1 x2 x3))

; compl : int -> term -> term
(ff:def-foreign-call ics_compl (x1 x2))

; inter : int -> term -> term -> term
(ff:def-foreign-call ics_inter (x1 x2 x3))

; union : int -> term -> term -> term
(ff:def-foreign-call ics_union (x1 x2 x3))

; diff : int -> term -> term -> term
(ff:def-foreign-call ics_diff (x1 x2 x3))

; sym_diff : int -> term -> term -> term
(ff:def-foreign-call ics_sym_diff (x1 x2 x3))

; bv_eps : unit -> term
(ff:def-foreign-call ics_bv_eps () )

; bv_zero : int -> term
(ff:def-foreign-call ics_bv_zero (x1))

; bv_one : int -> term
(ff:def-foreign-call ics_bv_one (x1))

; bv_const : string -> term
(ff:def-foreign-call ics_bv_const ((x1 (* :char))))

; bv_conc : int * term -> int * term -> term
(ff:def-foreign-call ics_bv_conc (x1 x2))

; bv_extr : int * term -> int -> int -> term
(ff:def-foreign-call ics_bv_extr (x1 x2 x3))

; bv_and : int -> term -> term -> term
(ff:def-foreign-call ics_bv_and (x1 x2 x3))

; bv_or : int -> term -> term -> term
(ff:def-foreign-call ics_bv_or (x1 x2 x3))

; bv_xor : int -> term -> term -> term
(ff:def-foreign-call ics_bv_xor (x1 x2 x3))

; fresh : term list -> term
(ff:def-foreign-call ics_fresh (x1))

; new_var : string -> term
(ff:def-foreign-call ics_new_var ((x1 (* :char))))

; tag : term -> int
(ff:def-foreign-call ics_tag (x1))

; is_var : term -> bool
(ff:def-foreign-call ics_is_var (x1))

; is_app : term -> bool
(ff:def-foreign-call ics_is_app (x1))

; is_tup : term -> bool
(ff:def-foreign-call ics_is_tup (x1))

; is_proj : term -> bool
(ff:def-foreign-call ics_is_proj (x1))

; is_lookup : term -> bool
(ff:def-foreign-call ics_is_lookup (x1))

; is_update : term -> bool
(ff:def-foreign-call ics_is_update (x1))

; is_ptrue : term -> bool
(ff:def-foreign-call ics_is_ptrue (x1))

; is_pfalse : term -> bool
(ff:def-foreign-call ics_is_pfalse (x1))

; is_ite : term -> bool
(ff:def-foreign-call ics_is_ite (x1))

; is_equal : term -> bool
(ff:def-foreign-call ics_is_equal (x1))

; is_lt : term -> bool
(ff:def-foreign-call ics_is_lt (x1))

; is_le : term -> bool
(ff:def-foreign-call ics_is_le (x1))

; is_empty_set : term -> bool
(ff:def-foreign-call ics_is_empty_set (x1))

; is_full_set : term -> bool
(ff:def-foreign-call ics_is_full_set (x1))

; is_compl : term -> bool
(ff:def-foreign-call ics_is_compl (x1))

; is_inter : term -> bool
(ff:def-foreign-call ics_is_inter (x1))

; is_union : term -> bool
(ff:def-foreign-call ics_is_union (x1))

; is_setite : term -> bool
(ff:def-foreign-call ics_is_setite (x1))

; pp_term : term -> unit
(ff:def-foreign-call ics_pp_term (x1) :returning :void)

; eq_term : term -> term -> bool
(ff:def-foreign-call ics_eq_term (x1 x2))

; compare : term -> term -> int
(ff:def-foreign-call ics_compare (x1 x2))

; set_verbose : int -> unit
(ff:def-foreign-call ics_set_verbose (x1) :returning :void)

; empty_state : unit -> state
(ff:def-foreign-call ics_empty_state () )

; find : state -> term -> term
(ff:def-foreign-call ics_find (x1 x2))

; use : state -> term -> term list
(ff:def-foreign-call ics_use (x1 x2))

; pp_find : state -> unit
(ff:def-foreign-call ics_pp_find (x1) :returning :void)

; pp_use : state -> unit
(ff:def-foreign-call ics_pp_use (x1) :returning :void)

; pp_universe : state -> unit
(ff:def-foreign-call ics_pp_universe (x1) :returning :void)

; universe : state -> term -> bool
(ff:def-foreign-call ics_universe (x1 x2))

; is_consistent : result -> bool
(ff:def-foreign-call ics_is_consistent (x1))

; is_redundant : result -> bool
(ff:def-foreign-call ics_is_redundant (x1))

; is_inconsistent : result -> bool
(ff:def-foreign-call ics_is_inconsistent (x1))

; is_valid : state -> term -> bool
(ff:def-foreign-call ics_is_valid (x1 x2))

; is_unsat : state -> term -> bool
(ff:def-foreign-call ics_is_unsat (x1 x2))

; process : state -> term -> result
(ff:def-foreign-call ics_process (x1 x2))

; process_list : state -> term list -> result
(ff:def-foreign-call ics_process_list (x1 x2))

; norm : state -> term -> term
(ff:def-foreign-call ics_norm (x1 x2))

; canon : state -> term -> term
(ff:def-foreign-call ics_canon (x1 x2))

; reset : unit -> unit
(ff:def-foreign-call ics_reset ()  :returning :void)

; gc : unit -> unit
(ff:def-foreign-call ics_gc ()  :returning :void)

; flush : unit -> unit
(ff:def-foreign-call ics_flush ()  :returning :void)

; empty_istate : unit -> istate
(ff:def-foreign-call ics_empty_istate () )

; current_state : istate -> state
(ff:def-foreign-call ics_current_state (x1))

; push : istate -> unit
(ff:def-foreign-call ics_push (x1) :returning :void)

; pop : istate -> unit
(ff:def-foreign-call ics_pop (x1) :returning :void)

; iprocess : istate -> term -> result
(ff:def-foreign-call ics_iprocess (x1 x2))

; is_nil : 'a list -> bool
(ff:def-foreign-call ics_is_nil (x1))

; cons : 'a -> 'a list -> 'a list
(ff:def-foreign-call ics_cons (x1 x2))

; head : 'a list -> 'a
(ff:def-foreign-call ics_head (x1))

; tail : 'a list -> 'a list
(ff:def-foreign-call ics_tail (x1))

; pair : 'a -> 'b -> 'a * 'b
(ff:def-foreign-call ics_pair (x1 x2))

; fst : 'a * 'b -> 'a
(ff:def-foreign-call ics_fst (x1))

; snd : 'a * 'b -> 'b 
(ff:def-foreign-call ics_snd (x1))

; num_of_int : int -> q
(ff:def-foreign-call ics_num_of_int (x1))

; string_of_num : q -> string
(ff:def-foreign-call ics_string_of_num (x1))

; num_of_string : string -> q
(ff:def-foreign-call ics_num_of_string ((x1 (* :char))))
