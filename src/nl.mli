(*
 * The contents of this file are subject to the ICS(TM) Community Research
 * License Version 1.0 (the ``License''); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.icansolve.com/license.html.  Software distributed under the
 * License is distributed on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing rights and limitations under the License.  The Licensed Software
 * is Copyright (c) SRI International 2001, 2002.  All rights reserved.
 * ``ICS'' is a trademark of SRI International, a California nonprofit public
 * benefit corporation.
 *)

(** Nonlinear inferences.

  @author Harald Ruess
  @author N. Shankar

  A nonlinear {i context} consists of equalities of the form [x = y*z] 
  with [x], [y], [z] variables.

  The following invariants are maintained.
  - Right-hand sides of context equalities [x = a] are kept in 
  canonical form.  That is, if the variable equality [y = z]
  has been merged using {!Nl.merge}, then the noncanonical [y]
  is not appearing on any right-hand side. 
  - Also, if [x = a] and [y = b] in a context, then the 
  variables [x] and [y] are different (that is, they are not {!Term.eq})
  - If [u = y * v] in a context, then [y] is always {i atomic} in the 
  sense that it is an {i original} variable from one of the arguments
  of {!Nl.process} or {!Nl.name}, whereas [u], [v] may be {i generated}
  variables.

  Forward chaining is used to keep contexts {i confluent}
  - [x' = y * v], [z = x*u], [x =v x'] ==> [z = y * v * u]
  with [=v] generated by the the current variable partitioning.

  This module provides
  - functions for accessing nonlinear contexts,
  - a canonizer for nonlinear products,
  - procedure {!Nl.process} for propagating equalities over pure 
  nonlinear terms,
  - {!Nl.merge} for propagating variable equalities,
  - and {!Nl.propagate} for propagating linear equalities 
  into a nonlinear context.
*)

type t
  (** Representation of a nonlinear context as a conjunction
    of equalities [x = y*v]. *)

val eq : t -> t -> bool
  (** [eq s1 s2] holds if the respective solution sets of [s1] 
    and [s2] are identical. *)

val pp : t Pretty.printer
  (** Pretty.printing nonlinear contexts. *)

val apply : t -> Term.t -> Term.t * Jst.t
  (** [apply s x] returns [a] if [x = a] is in [s]; 
    otherwise [Not_found] is raised. *)

val find : t -> Term.t -> Term.t * Jst.t
  (** [find s x] returns [a] if [x = a] is in [s], and [x] otherwise. *)
  
val inv : t -> Term.t -> Term.t * Jst.t
  (** [inv s a] returns [x] if [x = a] is in [s]; otherwise
    [Not_found] is raised. *)

val dep : t -> Term.t -> Term.Var.Set.t
  (** [dep s y] returns the set of [x] such that [x = a] in [s]
    and [y] occurs in [a]. *)

val is_dependent : t -> Term.t -> bool
  (** [is_dependent s x] holds iff there is an [a] such that [x = a] in [s]. *)

val is_independent : t -> Term.t -> bool
  (** [is_independent s y] holds iff [y] occurs in some [a] such that
    [x = a] in [s]. *)

val fold : (Term.t -> Term.t * Jst.t -> 'a -> 'a) -> t -> 'a -> 'a
  (** [fold f s e] applies [f x (a, rho)] for each [x = a] with justification
    [rho] in [s] and accumulates the result starting with [e]. The order of
    application is unspecified. *)

val empty : t
  (** Empty context. *)

val is_empty : t -> bool
  (** [is_empty s] holds iff [s] represents the empty context. *)

val replace : Partition.t * t -> Jst.Eqtrans.t
  (** For a pure {!Th.nl} term [a], [replace (p, s) a] returns 
    a pure term with all variables equal to a dependent variables 
    in [s] expanded. *)

val abstract : Partition.t * t -> Jst.Eqtrans.t
  (** [abstract (p, s) a] recursively replaces subterms [x * v] of [a]
    with [y'] if [y = x * v] in [s] with [y] and [y'] equal modulo [p]. *)

val can : Partition.t * t -> Jst.Eqtrans.t
  (** For {!Th.nl}-pure terms [a], [b], the {i canonical} 
    form [can (p, s) a] is equal to [can(p, s) b] 
    iff [a = b] is {!Th.nl}-valid in [(p, s)]. *)

val name : Partition.t * t -> Jst.Eqtrans.t
  (** For a {!Th.nl}-pure term [a], [name (p, s) a] returns
    a variable [y] equal to [a] in the (destructively) updated 
    configuration [(p, s)]. *)

val merge : Partition.t * t -> Fact.Equal.t -> unit
  (** For an equality [e] of the form [x = y] with
    variables [x], [y], [merge (p, s) e] destructively
    updates the configuration [(p, s)] to propagate this
    equality. This updated version is equivalent
    to the input configuration conjoined with the input equality.
    As another side effect, nonnegativity constraints might be deduced
    and added to {!Fact.Nonnegs}. *)

val process : Partition.t * t -> Fact.Equal.t -> unit
  (** For an equality [e] of the form [a = b] with
    [a], [b] {!Th.nl}-pure, [merge (p, s) e] destructively
    updates the configuration [(p, s)] to propagate [e].
    This updated version is equivalent to the input configuration 
    conjoined with the input equality. 
    As another side effect, nonnegativity constraints might be deduced
    and added to {!Fact.Nonnegs}. *)


val propagate : Partition.t * La.t * t -> Fact.Equal.t -> unit
  (** For a solved equality [x = a] with [a] a linear arithmetic
    term, [propagate (p, la, nl) e] deduces consequences from
    this equality and the configuration [(p, nl)] by plugging
    in this equality into equalities [nl]. As a side effect,
    [la], [nl], [p] might be destructively updated. *)

val copy : t -> t
 (** The update functions {!Nl.name}, {!Nl.merge},
   and {!Nl.process} {b destructively} update equality sets. 
   The function [copy s] can be used to protect state [s] against these 
   updates. For example, {i let s' = Nl.copy s in ...} protects [s]
   against updates in [s']. *)
  

