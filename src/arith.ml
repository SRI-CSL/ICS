(*i*)
open Tools
open Hashcons
open Mpa
open Term
(*i*)

type monomial = Q.t * (term list) hashed
      
let mk_mult = function
  | [] -> hc (Arith(Num(Q.one)))
  | [t] -> t
  | l -> hc (Arith(Times l))
	       
let mk_add = function
  | [] -> hc (Arith(Num(Q.zero)))
  | [t] -> t
  | l -> hc (Arith(Plus l))  
		  
(*s Constants *)

let num q = hc (Arith(Num(q)))
let zero  = num Q.zero
let one  = num Q.one

let is_one = function
  | {node=Arith (Num q)} when Q.equal q Q.one -> true
  | _ -> false

let is_zero = function
  | {node=Arith (Num q)} when Q.is_zero q -> true
  | _ -> false

(*s Building a power product *)

let pproduct l =
  match l with
  | [t] -> t
  | _ -> mk_mult l

(* Translations between arithmetic terms and polynomials

    A Polynomial is generated by the grammar:
      poly ::= monomial
             | monomial + poly

      monomial ::= q
                 | pproduct 
                 | q * pproduct    where q <> 1

      pproduct ::= t0 * ... * tn      where n >= 0
  *)
   
module PolyCache = Hasht.Make(
  struct 
    type t = term
    let equal = (==) 
    let hash x = x.tag 
  end)
	 
let table = PolyCache.create 17     (* Hashing of translations *)
                                (* causes occasional floating exception... *)
		   
let to_mono t =
  match t.node with
    | Arith(Num q) ->
	q,[]
    | Arith(Times((x::xl) as l)) ->
	(match x.node with Arith(Num q) -> q, xl | _ -> Q.one, l)
    | Arith _  ->
	assert false
    | _ ->
	Q.one, [t]

let to_poly t =
  try
    PolyCache.find table t
  with
      Not_found ->
	let p = Poly.monomial (to_mono t) in
	PolyCache.add table t p; p
		      
let of_mono (q,xl) =
  if Q.is_zero q then zero
  else match xl.node with
    | [] -> num q
    | [t] -> if Q.is_one q then t else mk_mult [num q; t]
    | l -> mk_mult (if Q.is_one q then l else num q :: l)
	  
let of_poly p =
  let t =
    let l = Poly.to_list p in
    mk_add (List.map of_mono l)
  in
  PolyCache.add table t p; t
	    
let of_pproduct {node=xl} = mk_mult xl

    
(*s Operations on the coefficients of a polynomial *)

let mapq f t = of_poly (Poly.mapq f (to_poly t))

let neg     = mapq Q.minus
let divq q  = mapq (Q.div q)
let multq q = mapq (Q.mult q)
let addq q  = mapq (Q.add q)

		
(*s Adding Polynomials *)

let add2 (t1,t2) = of_poly (Poly.add2 (to_poly t1) (to_poly t2))

let addl tl =
  of_poly (Poly.add (List.map to_poly tl))
  
let add = Tools.profile "Add" (cachel 107 addl)

let incr t = add2 (t, one)
  
let sub (t1,t2) = add2 (t1,neg t2)

let mult2 (t1,t2) =
  of_poly (Poly.mult2 (to_poly t1) (to_poly t2))

let multl tl =
  of_poly (Poly.mult (List.map to_poly tl))

let mult = Tools.profile "Mult" (cachel 107 multl)
	
(*s Iterators *)

let map f t = of_poly (Poly.map f (to_poly t))


(*s Checking if a term is syntactically known to be less (or equal)
    then another one
  *)

let le t1 t2 =
  t1 == t2 ||
  (match t1.node,t2.node with
     | Arith(Num q1), Arith(Num q2) -> Q.le q1 q2
     | _ -> false)

let lt t1 t2 =
  match t1.node,t2.node with
    | Arith(Num q1), Arith(Num q2) -> Q.lt q1 q2
    | _ -> false

(*s Test if [s] occurs interpreted in [t] *)

let occurs s t =
  let rec occ t = 
    s == t ||
    match t.node with
      | Arith a ->
	  (match a with
	     | Num _ -> false
	     | Times l -> List.exists occ l
	     | Plus l -> List.exists occ l)
      | _ -> false
  in
  occ t


(*s {\bf The solver.}  *)

(*s The following function extracts a monomial which is either a
    variable or an uninterpreted term, from a polynomial [z]. If such
    a monomial [m] exists, then the result is [(z0,Some m)] where
    [z=z0-m]; if there is no such monomial, then the result is
    [(z,None)]. *)

(*s Given an equation [x - y = 0], look for a monomial [r] in [x - y]
    satisfying [pred]. Test for the particular cases when [r=None]:
    if [x - y] is a  constant, return either [true] or [false];
    otherwise we return $\{x - y = 0\}$. 
    When [r = Some (m,n)], return $\{m = \frac{x - y}{n}\}$.
 *)

let qsolve x t =
  match Poly.qsolve x (to_poly t) with
    | [] -> []
    | [x,p] -> [of_pproduct x, of_poly p]
    | _ -> assert false

	  
module Euclid = Euclid.Make(
  struct
    type t = term
    let num = num
    let fresh () = Var.fresh ("k",Some(Int),None) []
    let ( + ) = (fun x y -> add2 (x,y))
    let ( - ) = (fun x y -> sub (x,y))
    let ( * ) = (fun x y -> mult2 (x,y))
  end)

let zsolve t =
  let rho = Poly.zsolve Euclid.solve (to_poly t) in
  List.map (fun (x,t) -> (of_pproduct x, t)) rho

let is_integer t = false

let is_diophantine =
  cache 1007 (fun t -> Poly.is_diophantine is_integer (to_poly t))


(*s Solving of linear arithmetic equations [x = y], which
    is reduced to [x - y = 0]. If every monomial of the lhs
    is an integer then use [zsolve] to solve this linear
    Diophantine equation in the integers; otherwise simply
    solve in the domain of the rationals/reals using [qsolve].
  *)
     
let solve x (s,t) =
  let p = sub (s,t) in
  if is_diophantine p then zsolve p else qsolve x p




