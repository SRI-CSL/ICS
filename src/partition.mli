(* 
 * The MIT License (MIT)
 *
 * Copyright (c) 2020 SRI International
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *)

(** {i Inference system for the theory of pure identity.}
   
  This module provides an inference system for
  - building up {i union-find} structures for finite conjunctions of
  variable equalities [E] and variable disequalities [D], and for
  - deciding the {i uniform word problems} [V |= E,D => x = y] 
  and [V |= E,D => x <> y] in the {i theory of pure identify}. 

  @author Harald Ruess
*)

(** Input signature for {!Partition.Make}. *)
module type VAR = sig
  type t
    (** Representation of variables. *)

  val equal : t -> t -> bool
    (** Equality on variables. *)

  val compare : t -> t -> int
    (** A total ordering on variables. 
      This is a two-argument function [f] such that
      [f x y] is [0] iff [equal x y], and 
      [f x y] is strictly negative if [x] is smaller than [y],
      and [f x y] is strictly positive if [y] is greater than [x]. *)

  val preference : t -> t -> int
    (** A partial ordering on variables. [prefence x y] is said to 
      be {i defined} if it does not throw [Not_found]. If [preference x y] is 
      defined, then [preference y x] is also assumed to be defined 
      and [preference x y > 0] iff [preference y x < 0]. *)

  val hash : t -> int
    (** Nonnegative hash value of a variable. *)

  val pp : Format.formatter -> t -> unit
    (** Pretty-printing a variable. *)
end

(** {i Inference system} for online processing of variable equalities
  and variable disequalities. The configuations of the inference
  system represent the conjunction of a finite set [E] of equalities
  and a finite set [D] of disequalities. [E] induces an equivalence
  class [=E]on variables with [x =E y] iff [E |= x = y] in the
  theory of pure identity. *)
module type INFSYS = sig
  type var
    (** Representation of variables. *)

  module Disequalities : (Sets.S with type elt = var * var)
    (** Finite set of variables disequalities. *)

  module Equalities : (Maps.S with type key = var and type value = var)
    (** Finite set of variable equalities [x = y] represented as a map 
      [x |-> y] with [x], [y] variables. As an invariant, if
      [Var.preference x y > 0], then there is no binding [y |-> x] 
      in such a map. *)

  type t
    (** Representation of configurations. *)

  val equalities : unit -> Equalities.t
    (** Returns a representation of the set of variable equalities in the 
      current configuration. *)

  val disequalities: unit -> Disequalities.t 
    (** Returns a representation of the set of variable disequalities in the 
      current configuration. *)

  val current : unit -> t  
    (** Returns a representation of the current configuration. *)

  val reset : unit -> unit 
    (** Reset the current configuration to the [empty] configuration. 
      [reset()] is synonymous with [initialize empty]. *)

  val initialize : t -> unit  
    (** Initialize the current configuration with the argument 
      configuration. *)

  val unchanged : unit -> bool
    (** [unchanged()] holds iff the current configuration is logically 
      equivalent with the initial configuration as set by [initialize] 
      or [reset]. *)

  val find : var -> var
    (** [find x] returns the canonical representative [y] for the 
      equivalence class [=E] containing [x]. In particular, 
      [canonical (find x)] holds. *) 

  val canonical : var -> bool
    (** [canonical x] if [x] is the canonical representative of the equivalence
      class generated by the current variable equalities. *)

  module Varset : (Sets.S with type elt = var)
    (** Representation of a set of variables. *)

  val deqs : var -> Varset.t
    (** [y] in [deqs x] iff [E,D |= x <> y]. This set is not necessarily 
      minimal as it may contain [y], [y'] with [v =E v']. *)

  val eqs : var -> Varset.t
    (** [y] in [eqs x] iff [E |= x = y]. *)

  val equal : var -> var -> bool
    (** [equal x y] holds iff [E |= x = y]. *)

  val diseq : var -> var -> bool
    (** [diseq x y] holds iff [E,D |= x <> y]. *)

  val empty : t  
    (** The empty configuration. *)

  exception Unsat
  val union : (var -> var -> unit) -> var -> var -> unit
    (** [union x y] extends the current equalities [E] to [E'] such 
      that [E' |= x = y] or throws [Unsat] if [x = y] is inconsistent 
      with the current configuration [(E, D)].

      More specifically, if [E |= x = y], then the current configuration is 
      unchanged, that is [E' = E] and [unchanged()] still continues to 
      hold. 

      For [x], [y] canonical, if [preference x y] holds, then [x] 
      is chosen as a canonical representative of the extended equivalence 
      class. *)

  val separate : var -> var -> unit 
    (** [separate x y] adds the disequality [x <> y] to the current 
      configuration [(E, D)] or throws [Unsat] if [E, D |= x = y]. 
      If [E, D |= x <> y], then the current configuration
      is left unchanged. *)

  val iterEquiv : (var -> unit) -> var -> unit
    (** [iterEquiv f x] applies [f y] for each [y] with [x =E y].  
      This operation is linear in the number of equalities in [E]. Since no
      specific indices are being used, this iteration also requires iterating
      over all noncanonical variables [z] with [z =E x], and should therefore
      be avoided. *)

  val chooseEquiv : (var -> bool) -> var -> var
    (** [chooseEquiv f x] chooses [y] with [f y] and [x =E y].
      If there is no such [y], then [Not_found] is raised. *)

  val iterDiseqs : (var -> var -> unit) -> var -> unit
    (** [iterDiseqs f x] applies [f x' y'] with [x' =E x], [y'] canonical,
      and [E, D |= x' <> y']. [f x' y'] is called at most once for any such
      disequality, and the order of application is unspecified. *)
end

(** {i Inference system for the theory of pure identity}
  for variables [Var.t]. *)
module Make(Var: VAR): (INFSYS with type var = Var.t)
