(*
 * The contents of this file are subject to the ICS(TM) Community Research
 * License Version 2.0 (the ``License''); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.icansolve.com/license.html.  Software distributed under the
 * License is distributed on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing rights and limitations under the License.  The Licensed Software
 * is Copyright (c) SRI International 2003, 2004.  All rights reserved.
 * ``ICS'' is a trademark of SRI International, a California nonprofit public
 * benefit corporation.
 *)

(** The state [s] of the decision procedures for linear arithmetic is separated
  into {i unrestricted} and {i restricted} solved equalities and consists 
  of a pair [(r, t)], where
  - [r] is a set of solutions [x = a], where [x] is {i unrestricted},
    that is, a nonslack variable, and
  - [t] is a set of solutions [k = b], where [k] is a {i restricted} 
    slack variable and all variables in [b] are also {i restricted}.

  In addition, neither [a] nor [b] are variable terms.

  The union of the solution sets [(r, t)] is {i functional} in that there 
  is no [x = a1] and [x = a2] in [(s, r)], and it is {i inverse functional} 
  in that there are no [x1 = a] and [x2 = a].  

  A key point to remember in generating explanations from
  Simplex  is that each slack variable is associated with
  an inequality.  This inequality is included in the explanation
  only when the slackness of the corresponding slack variable is
  used, and when this happens we say that the slack variable is
  added to the explanation.  This happens when
  - A new inequality is maximized below 0 and a contradiction is
  generation, in which case all the negative slacks at the point
  of maximization are added to the explanation, or
  - When an equality [k = 0] is generated by maximizing [k] to [0], and
  again the negative slacks in the maximized equality are added
  to the explanation.

  The notations used are
  - [q], [p] for rational numbers,
  - [a], [b] for arbitrary terms, and [x], [y], [z] for variable terms
  - [s] for a solution state [(r, t)] and [r], [t] for the respective components,
  - [e] for equality facts ({!Fact.Equal.t}), [d] for disequality 
    facts ({!Fact.Diseq.t}), and [c] for arithmetic constraints, and
  - Greek letters for justifications ({!Jst.t}).
*)

open Mpa

let debug = Version.debug ()

module A = Linarith
module M = A.Monomials


(** {6 Basic Datastructures} *)

(** Finite map with term variables as keys. *)
module Map = Term.Map

(** Finite set of term variables. *)
module Set = Term.Set

(** Operations on monomials of a linear arithmetic term. *)
module Monomials = A.Monomials

let is_pure = Term.is_pure A.theory 
let is_var = Term.is_var 
let is_num = A.is_num
let is_homogeneous t = Q.is_zero (A.constant_of t)
let occ = Term.occurs


(** {6 Arithmetic Judgements} *)

module J = struct

  (** Inherited rules from module {!Judgement}. *)
  let mk_refl = Judgement.mk_refl
  let mk_sym = Judgement.mk_sym
  let mk_trans = Judgement.mk_trans
  let mk_join = Judgement.mk_join
  let mk_replace_in_equal e1 e2 e = Judgement.mk_replace_in_equal [e1; e2] e
  let mk_replace_in_diseq = Judgement.mk_replace_in_diseq
  let mk_replace_in_atom = Judgement.mk_replace_in_atom
  let mk_replace_in_nonneg = Judgement.mk_replace_in_nonneg
  let mk_replace_in_pos = Judgement.mk_replace_in_pos
  let mk_transform_diseq = Judgement.mk_transform_diseq
  let mk_transform_equal = Judgement.mk_transform_equal
  let mk_transform_nonneg = Judgement.mk_transform_nonneg
  let mk_transform_pos = Judgement.mk_transform_pos
  let mk_transform_rhs_equal = Judgement.mk_transform_rhs_equal
 
  let mk_alias = Judgement.mk_alias

  let is_refl e = (e#rhs == e#lhs)

 (** If [e |- s1 = s2] and [(t1 = t2) <=> (s1 = s2)], 
   then [equiv e t1 t2 |- t1 = t2]. *)
  class equiv (e: Judgement.equal) (t1: Term.t) (t2: Term.t) = 
    (object
       inherit Judgement.Top.equal
       method lhs = t1
       method rhs = t2    
       method name = "equiv[la]"
       method hyps = Judgement.mk_singleton (e:>Judgement.atom)
     end: Judgement.equal)

  let mk_equiv e t1 t2 = new equiv e t1 t2

  class equal0 (e: Judgement.equal) t = object
    inherit equiv e t (A.mk_zero())
    method name = "equal0[la]"
  end

  let mk_equal0 e = 
    let t = A.mk_sub e#lhs e#rhs in
      new equal0 e t


  class diseq0 (d: Judgement.diseq) t = object
    inherit Judgement.Top.diseq
    method lhs = t
    method rhs = A.mk_zero()
    method hyps = Judgement.mk_singleton (d:>Judgement.atom)
    method name = "diseq0[la]"
  end

  let mk_diseq0 d =
    let t = A.mk_sub d#lhs d#rhs in
    let t = if Q.is_neg (A.constant_of t) then A.mk_neg t else t in
      new diseq0 d t

  (** If [e |- a = b], then [solve e |- x = c] with [x] in [vars(a, b)] *)
  class solve e x c = 
    (object
       inherit equiv e x c
       method name = "qsolve[la]"
       method validate = not (A.is_interp x) && not(Term.occurs x c)
      end: Judgement.equal)

  let mk_solve e =
    let a = e#lhs and b = e#rhs in
    let x, c = A.qsolve (A.mk_sub a b) in
      new solve e x c

  let mk_solve_for x e = 
    let c = A.qsolve_for x (A.mk_sub e#lhs e#rhs) in
      new solve e x c

  class isolate e x c = object
    inherit solve e x c
    method name = "isolvate[la]"
    method validate = is_var e#lhs && not(Term.occurs e#lhs e#rhs)
  end

  let mk_isolate x e =
    let y = e#lhs and a = e#rhs in
      assert(is_var y && not(Term.occurs y a));
      let b = A.qsolve_solved_for x (y, a) in
	new isolate e x b

  class  pivot (e: Judgement.equal) (x: Term.t) (c: Term.t) = object
    inherit solve e x c
    method name = "pivot[la]"
  end
      
  let mk_pivot v e =
    assert(is_var v);
    let u = e#lhs and a = e#rhs in
      assert(is_var u && not(Term.occurs u a));
      let a' = A.qsolve_solved_for v (u, a) in
	new pivot e v a' 


  (** [minimize cl t |- t >= 0] for [t] of the form [c{0} + c{1}*x{1} + ... +c{n}*x{n}]. *)
  class minimize (cl: Judgement.nonneg list) t = (object
     inherit Judgement.Top.nonneg
     method arg = t
     method hyps = Judgement.of_nonneg_list cl
     method name = "minimize"
     method validate = 
       Q.is_nonneg (A.constant_of t) &&
       M.is_empty M.Neg t
  end: Judgement.nonneg)

  let mk_minimize cl t = new minimize cl t

  (** [maximize cl t |- c{0} - t >= 0] for [t] of the form [c{0} - c{1}*x{1} - ... - c{n}*x{n}]. *)
  class maximize (cl: Judgement.nonneg list) t = (object
     inherit Judgement.Top.nonneg
     method arg = A.mk_sub (A.mk_num (A.constant_of t)) t
     method name = "maximize"
     method hyps = Judgement.of_nonneg_list cl
     method validate = M.is_empty M.Pos t
  end: Judgement.nonneg)

  let mk_maximize cl t = new maximize cl t

  (** [intclose cl t |- t in int] if 
    for all [x] in [vars(t)] there exists [c |- x in int] in [cl]. *)
  class intclose (cl: Judgement.cnstrnt list) (t: Term.t) = 
    (object
       inherit Judgement.Top.cnstrnt
       method arg = t
       method name = "intclose[la]"
       method cnstrnt = Cnstrnt.Int
       method hyps = Judgement.of_cnstrnt_list cl
     end : Judgement.cnstrnt)
  
  let mk_intclose cl t = new intclose cl t

  (** [constant_pos q |- q > 0] for [q>0]. *)
  class constant_pos q = (object
     inherit Judgement.Top.pos
     method arg = A.mk_num q
     method name = "pos[la]"
     method hyps = Judgement.mk_empty
     method validate = Q.is_pos q
  end : Judgement.pos) 

  let mk_constant_pos q = new constant_pos q

  (** If [n1 |- t1 >= 0] and [n2 |- t2 >= 0], then [nonnegclose c1 n1 c2 n2 |- c1*t1 + c2*t2 >= 0]. *)
  class nonnegclose c1 (n1: Judgement.nonneg) c2 (n2: Judgement.nonneg) = 
    (object
       inherit Judgement.Top.nonneg
       method arg = A.mk_add (A.mk_multq c1 n1#arg) (A.mk_multq c2 n2#arg)
       method name = "add_nonneg[la]"
       method hyps = Judgement.of_nonneg_list [n1; n2]
       method validate = Q.is_nonneg c1 && Q.is_nonneg c2
     end : Judgement.nonneg)
  
  let mk_add_nonneg n1 n2 = 
    new nonnegclose Q.one n1 Q.one n2

  (** If [n |- t >= 0] and [p |- -t < 0], then [contra n p |- false]. *)
  class contra (n: Judgement.nonneg) (p: Judgement.pos) = 
    (object
       inherit Judgement.Top.unsat
       method name = "unsat[la]"
       method hyps =Judgement.mk_add(n:>Judgement.atom)(Judgement.mk_singleton(p:>Judgement.atom))
       method validate = Term.eq n#arg (A.mk_neg p#arg)
     end : Judgement.unsat)

  let mk_contra n p = new contra n p

  let mk_contra2 a1 a2 = failwith "contra: to do 2"

  let mk_contra_equal = Judgement.mk_contra

  (** If [n1 |- t >= 0] and [n2 |- -t >= 0], then [deduce0 n1 n2 |- t = 0]. *)
  class deduce0 (n1: Judgement.nonneg) (n2: Judgement.nonneg) = 
    (object
       inherit Judgement.Top.equal
       method lhs = n1#arg
       method name = "deduce0[la]"
       method rhs = A.mk_zero ()
       method hyps = failwith "hyps: to do 3"
       method validate = Term.eq n1#arg (A.mk_neg n2#arg)
     end: Judgement.equal)

  let mk_deduce0 n1 n2 = new deduce0 n1 n2

  (** If [e |- t = 0] and [x] in [vars(t)], then [independent e x |- x = 0]. *)
  class independent (e: Judgement.equal) x = 
    (object
       inherit Judgement.Top.equal
       method lhs = x
       method name = "independent[la]"
       method rhs = A.mk_zero ()
       method hyps = Judgement.mk_singleton (e:>Judgement.atom)
       method validate = occ x e#lhs && A.is_zero e#rhs
     end: Judgement.equal)

  let mk_independent e x = new independent e x

  (** If [constant_diseq q |- q <> 0] for [q<>0]. *)
  class constant_diseq (q: Q.t) = 
    (object
       inherit Judgement.Top.equal
       method lhs = A.mk_num q
       method name = "constant_diseq[la]"
       method rhs = A.mk_zero ()
       method hyps = Judgement.mk_empty
       method validate = not(Q.is_zero q)
     end: Judgement.diseq)
    
  let mk_constant_diseq q = new constant_diseq q

  (** If [e |- t1 = t2], then [weaken e |- t1 - t2 >= 0]. *)
  class weaken (e: Judgement.equal) = 
    (object
       inherit Judgement.Top.nonneg
       method arg = A.mk_sub e#lhs e#rhs
       method name = "weaken[la]"
       method hyps = Judgement.mk_singleton (e:>Judgement.atom)
     end: Judgement.nonneg)
    
  let mk_weaken e = new weaken e

  (** If [e{i} |- x{i} = a{i}], then [replace [e{1};...;e{n}] t t'|- t t'] *)
  class replace (el: Judgement.equal list) t t' = 
    (object
       inherit Judgement.Top.equal
       method lhs = t 
       method name = "replace[la]"
       method rhs = t'
       method hyps = Judgement.of_equal_list el
     end: Judgement.equal)

  let mk_replace f t = 
    assert(is_pure t);
    let el = ref [] in
    let lookup x =
      let e = f x in
      let y = e#rhs in
	assert(Term.eq x e#lhs);
	if not(Term.eq x y) then
	  el := e :: !el;
	y
    in
    let t' = A.map lookup t in
      if t == t' then mk_refl t else new replace !el t t'

  let mk_replace1 e t = 
    let x = e#lhs in
    let lookup y = if Term.eq x y then e#rhs else y in
    let t' = A.map lookup t in
      new replace [e] t t'
 
  let replace x t = 
    let lookup y = if Term.eq x y then t else y in
      A.map lookup

  (** If [e1 |- x = a] and [e2 |- y = b] with [x] in [vars b],
    then [fuse e1 e2 |- y = b[x:=a]]. *)
  class fuse (e1: Judgement.equal) (e2: Judgement.equal) = (object
     inherit Judgement.Top.equal
     method lhs = e2#lhs
     method name = "fuse[la]"
     method rhs = replace e1#lhs e1#rhs e2#rhs
     method hyps = Judgement.of_equal_list [e1; e2]
     method validate = 
       is_var e1#lhs && 
       is_var e2#lhs && 
       occ e1#lhs e2#rhs
   end: Judgement.equal)

  let mk_fuse e1 e2 = new fuse e1 e2


  let pos_to_nonneg n = failwith "simplex: to do 9"
  let pos_to_diseq n = failwith "simplex: to do 10"

  (** Let [a = ceil(a) - def(a) = floor(a) + frac(a)].  If 
    [x = b + Sigma_i ci*xi], 
    then this can be rewritten as 
    [x = ceil(b) - def(b) + Sigma_i floor(ci)*xi + Sigma_i frac(ci)*xi]
    which can be rearranged as
    [x - ceil(b) - Sigma_i floor(ci)*xi = -def(b) + Sigma_i frac(ci)*xi].
    If all the [x] and [xi] range over non-negative integers, then the lhs is
    integer and the rhs is a non-negative integer (since all the fracs are
    non-negative and [def(b) > -1]).  So, we have to add the inequality that
    [-def(b) + Sigma_i frac(ci)*xi >= 0], proceed. *)
  class gomory e n1 n2 c1 c2 = 
    (object
       inherit Judgement.Top.nonneg
       method arg = 
	 let q' = A.constant_of e#rhs and t' = A.nonconstant_of e#rhs in
	   A.mk_addq (Q.minus (Q.def q')) (A.mapq Q.frac t')
       method name = "gomory[la]"
       method hyps = failwith "simplex: to do 11"
     end)

  let mk_gomory e n1 n2 c1 c2 = new gomory e n1 n2 c1 c2

end 


(** {6 Tableau Datastructure} *)

type t = {
  mutable regular: Judgement.equal Map.t;
  mutable tableau : Judgement.equal Map.t;
  mutable slacks : Judgement.nonneg Map.t;
  mutable dep_r : Dep.t; 
  mutable dep_t : Dep.t;
}

let empty () = {
  regular = Map.empty();
  tableau = Map.empty();
  slacks = Map.empty();
  dep_r = Dep.empty();
  dep_t = Dep.empty()
}

let copy s = {
  regular = Map.copy s.regular;
  tableau = Map.copy s.tableau;
  slacks = Map.copy s.slacks;
  dep_r = Dep.copy s.dep_r;
  dep_t = Dep.copy s.dep_t
}

(** Global state of Simplex procedure. *)
let state = ref (empty())
let unchanged = ref false


let protect f t =
  let save = copy !state in
    try let t' = f t in state := save; t' with exc -> 
      state := save; raise exc

(** {6 Restricted variables. *)

let mk_fresh_slack str rho =
  let k = Term.mk_fresh_var str in 
    Map.set k rho !state.slacks;
    k


(** {6 Constraint Restrictions} *)

module Preds = struct
  
  let is_intvar x = 
    assert(is_var x);
    V.Infsys.has_cnstrnt x Cnstrnt.Int <> None
      
  (** Test if pure linear arithmetic term is interpreted over the integers. *)
  let is_diophantine t =
    assert(is_pure t);
    Term.for_all is_intvar t

  let is_slack x =
    is_var x && Map.mem x !state.slacks

  let is_unrestricted_var x =
    is_var x && not(Map.mem x !state.slacks)

  let is_restricted t =
    assert(is_pure t);
    Term.for_all is_slack t

  exception Found of Term.t
  let choose_unrestricted t = 
    let unrestricted m = 
      let x = A.var_of m in
	if is_unrestricted_var x then raise(Found(x))
    in
      try
	M.iter M.All unrestricted t;
	raise Not_found
      with
	  Found(x) -> x

  (** A term [q + n1*x1 + nk*xk] is maximized at [q] if
    all [ni] are negative and all [xi] are restricted. *)
  let is_maximized t =
    assert(is_pure t);
    let is_neg_restricted m =
      assert(A.is_monomial m);
      Q.is_neg (A.coeff_of m) && is_slack (A.var_of m)
    in
      M.for_all M.All is_neg_restricted t
	
  let is_maximized_at q t =
    Q.equal q (A.constant_of t) && is_maximized t

  let is_maximized_below_zero t = 
    Q.is_neg (A.constant_of t) && is_maximized t 
      
  (** A term [q + p1*x1 + p2*xn] is minimized at [q] if
    all [pi] are positive and all [xi] are restricted. *)
  let is_minimized t =
    assert(is_pure t);
    let is_pos_monomial m =
      Q.is_pos (A.coeff_of m) && is_slack (A.var_of m)
    in
      M.for_all M.All is_pos_monomial t

  let is_maximized_at q t =
    Q.equal q (A.constant_of t) && is_minimized t

  let is_minimized_above_zero t = 
    Q.is_pos (A.constant_of t) && is_minimized t 

  let is_minimized_above_or_equal_to_zero t = 
    Q.is_nonneg (A.constant_of t) && is_minimized t

  (** Explanations *)
  module Explain = struct

    let slack x =
      assert(is_slack x);
      Map.find x !state.slacks

    let restricted t =
      let nl = ref [] in
      let jst_of_slack x =
	assert(is_slack x);
	nl := Map.find x !state.slacks :: !nl
      in
	Term.iter jst_of_slack t;
	!nl
	  
    (** Returns [rho] with [rho |- t - |t| >= 0]. *)
    let minimized t =
      assert(is_minimized t);
      let nn = ref [] in
      let accumulate x =
      assert(is_slack x);
	nn := Map.find x !state.slacks :: !nn
      in
	Term.iter accumulate t;
	J.mk_minimize !nn t

    (** [n |- |t| - t >= 0]. *)
    let maximized t =
      assert(is_maximized t);
      let nn = ref [] in
      let accumulate x =
	assert(is_slack x);
	nn := Map.find x !state.slacks :: !nn
      in
	Term.iter accumulate t;
	J.mk_maximize !nn t

    (** [n |- -t > 0]. *)
    let maximized_below_zero t =
      assert(is_maximized_below_zero t);
      failwith "simplex.maximized_below_zero: to do"

    (** [p |- t > 0]. *)
    let minimized_above_zero t =
      assert(is_minimized_above_zero t);
      failwith "simplex.minimized_above_zero: to do"

   (** [n |- t >= 0]. *)
    let is_minimized_above_or_equal_to_zero t = 
      assert(is_minimized_above_or_equal_to_zero t);
      failwith "simplex.is_minimized_above...: to do"
	  
    (** Returns [tau |- t in int]. *)
    let diophantine t =
      assert(is_diophantine t);
      let cl = ref [] in
      let jst x =
	assert(is_var x);
	match V.Infsys.has_cnstrnt x Cnstrnt.Int with
	  | Some(c) -> cl := c :: !cl
	  | None -> invalid_arg "not a diophantine term"
      in
	Term.iter jst t;
	J.mk_intclose !cl t  
  end
	  
end

open Preds


(** {6 Side effects} *)

(** Procedures to run when updating. *)
module Effect = struct
  type t = Term.t -> unit

  let procs = ref []

  let register p = (procs := p :: !procs)

  let call x = 
    let apply f = f x in
      List.iter apply !procs
end


(** Regular solution sets respresent set of equalities [x = t] with
  - [x] is not restricted
  - [t] is a pure linear arithmetic term or a restricted variable
  as a finite set of bindings [x |-> t]. *)
module R = struct

  let regular e = 
    is_var e#lhs && 
    is_pure e#rhs &&
    (if is_var e#rhs then is_slack e#rhs else true) &&
    not(occ e#lhs e#rhs)
   
  let dom e =
    assert(regular e);
    e#lhs

  let cod e = 
    assert(regular e);
    e#rhs

  let iter f = 
    let g _ e = assert(regular e); f e in
      Map.iter g !state.regular
	
  let to_set () =
    let acc = Judgement.Equals.empty () in
      iter (fun e -> Judgement.Equals.add e acc);
      acc

  let is_empty () =
    Map.is_empty !state.regular

  let pp fmt = 
    Format.fprintf fmt "@[r:"; 
    Judgement.Equals.pp fmt (to_set());
    Format.fprintf fmt "@]@;"
	
  let apply t =
    if is_unrestricted_var t then
      let e = Map.find t !state.regular in
	dom e, e
    else
      raise Not_found 
	
  let is_dependent x = 
    assert(is_var x);
    Map.mem x !state.regular
      
  let is_independent x =
    assert(is_var x);
    not(is_dependent x)
      
  let dep y = 
    assert(is_var y);
    let xs = Dep.find !state.dep_r y in
      assert(Dep.Set.for_all is_dependent xs);
      xs

  (** Return [(x, rho)] if [rho |- x = t] is in [s]. 
    If [t] is a constant, then traverse the data structure
    to find the inverse (an index for constants might be useful).  
    Otherwise, the dependency index on some variable [y] in [t] is 
    used to find [x = t]. *)
  exception Found of Judgement.equal
  let rec inv t =
    try invq (A.d_num t) with Not_found -> 
      try
	let y = Term.choose is_var t in
	let dy = Dep.find !state.dep_r y in
	  Dep.Set.iter
	    (fun x ->
	       try
		 let e = Map.find x !state.regular in
		   if Term.eq t (cod e) then raise(Found(e))
	       with
		   Not_found -> invalid_arg ("Simplex.R.inv: " ^ Term.to_string x))
	    dy;
	  raise Not_found
      with
	  Found(e) -> 
	    assert(regular e);
	    dom e, e
	      
  and invq q = 
    try
      iter (fun e -> if A.is_q q (cod e) then raise(Found(e)));
      raise Not_found
    with
	Found(e) -> 
	  assert(regular e);
	  dom e, e
	    
  let in_dom x = 
    assert(is_var x);
    Map.mem x !state.regular

  let in_cod t = 
    assert(is_pure t);
    try let _ = inv t in true with Not_found -> false

  let occurs_in_cod x =
    assert(is_var x);
    not(Dep.Set.is_empty (dep x))
    
  let occurs x = 
    assert(is_var x);
    is_dependent x || occurs_in_cod x
      
  let is_solved () =
    Map.for_all
      (fun _ e -> regular e && not(occurs_in_cod (dom e)))
      !state.regular

  module Dep = struct
    let find x = Dep.find !state.dep_r x
    let rem x y = Dep.remove x y !state.dep_r
    let add x y = Dep.add x y !state.dep_r
    module Set = Dep.Set
    let iter v f =
      assert(is_var v);
      try
	let dv = find v in
	  Set.iter
	    (fun u -> 
	       try f (Map.find u !state.regular) with Not_found -> 
		 invalid_arg "imprecise dependency")
	    dv
      with
	  Not_found -> ()
  end
      
  (** Remove binding [x |-> t] from regular substitution. *)
  let restrict x =
    assert(is_unrestricted_var x);
    try
      let e = Map.find x !state.regular in
	unchanged := false;
	Map.remove x !state.regular;
	Term.iter (Dep.rem x) (cod e)
    with
	Not_found -> ()
	  
  (** Deduce variable equality [x = y] between unrestricted variables. *)
  let deduce e =
    assert(is_unrestricted_var e#lhs && is_unrestricted_var e#rhs);
    V.Infsys.process_equal e

  (** Instantiate bindings [x |-> a] in regular substitution with [x |-> a[y:= b]] *)
  let rec fuse e =        
    let fuse1 x = 
      assert(is_unrestricted_var x);
      assert(is_dependent x);
      try
	let e1 = Map.find x !state.regular in  (* [e1 |- x = a]. *)
	let e2 = J.mk_fuse e e1 in             (* [e2 |- x = a'] *) 
	  assert(not(occ (dom e) (cod e2)));   (* with [a'] does not contain lhs of [e]. *)
	  replace e1 e2
      with
	  Not_found -> invalid_arg "over-approximating dependency"
    in
      try
	let dy = Dep.find (dom e) in
	  Dep.Set.iter fuse1 dy;
      with
	  Not_found -> ()

  (** Replace binding [x |-> a] by [x |-> a']. *)
  and replace e1 e2 =
    assert(regular e1);
    assert(regular e2);
    assert(Term.eq (dom e1) (dom e2));
    assert(not(Term.eq (cod e1) (cod e2)));
    let x = dom e1 and a = cod e1 in    (* [e1 |- x = a[y]]. *)
    let a' = cod e1 in                  (* [e2 |- x = a'].   *)
      assert(occ (dom e2) (cod e1));
      if is_unrestricted_var a' then 
	(restrict x; deduce e2)
      else
	(try
	   let e3 = snd(inv a') in      (* [e3 |- y = a']. *)
	   let e4 = J.mk_join e2 e3 in  (* ==> [join e2 e3 |- x = y]. *)
	     restrict x; deduce e4
	 with
	     Not_found ->
	       unchanged :=  false;
	       Map.set x e2 !state.regular;  
	       Effect.call x;
	       update_dependencies x a a')

  (** First, remove variables in [a] but not in [a'] from deps. 
    Second, add new variables from [a'] to deps. *)
  and update_dependencies x a a' = 
    let rem z = if not(Term.is_var_of z a') then Dep.rem x z in
      Term.iter rem a;   
      Term.iter (Dep.add x) a'
	
  (** Compose regular substition with the unitary substitition [x |-> a]. *)
  let rec compose e = 
    assert(regular e);
    assert(not(is_dependent (dom e)));
    fuse e;
    extend e;
    assert(is_solved ())

  and extend e = 
    assert(regular e);
    let x = dom e and t = cod e in  (* [e |- x = t]. *)
      assert(not(in_dom x));
      assert(is_unrestricted_var x);
      if is_unrestricted_var t then deduce e else 
	try
	  let e' = snd(inv t) in      (* [e' |- y = t]. *)
	    deduce (J.mk_join e e')
	with
	    Not_found -> 
	      unchanged := false;
	      Map.set x e !state.regular;
	      Term.iter (Dep.add x) t
      
  (** Return unrestricted variable [v] with [v = q] in [r], possibly extended. *)
  let rec var_of_num q = 
    try invq q with Not_found -> 
      let v = Term.mk_fresh_var "v" in
      let e = J.mk_alias v (A.mk_num q) in
	alias e;
	v, e
	
  and alias e =     (* [e |- x = t]. *)
    assert(regular e);
    let x = dom e and t = cod e in
      assert(not(in_dom x) && not(in_cod t) && not(is_var t));
      unchanged :=  false;
      Map.set x e !state.regular;
      Term.iter (Dep.add x) t
	      
end 

(** Tableau for respresenting sets of equalities [x = a]  as finite sets
  of bindings [x |-> a] with
  - [x] is restricted
  - [a] is a restricted pure linear arithmetic term, which is 
  neither a variable nor a constant. *)
module T = struct

  let tableau e = 
    let x = e#lhs and t = e#rhs in
      is_slack x &&
      not(is_var t) && not(is_num t) && 
      is_pure t && is_restricted t && 
      not(occ x t)
    
  let dom e = assert(tableau e); e#lhs
  let cod e = assert(tableau e); e#rhs

  let is_dependent x = 
    assert(is_slack x);
    Map.mem x !state.tableau
      
  let is_independent x =
    assert(is_slack x);
    not(is_dependent x)

  let iter f = 
    let g _ e = assert(tableau e); f e in
      Map.iter g !state.tableau

  let to_set () =
    let acc = Judgement.Equals.empty () in
    let add e = 
      assert(not(is_dependent (dom e)));
      Judgement.Equals.add e acc
    in
      iter add; acc

  let is_empty () =
    Map.is_empty !state.tableau

  let pp fmt = 
    Format.fprintf fmt "@[t:"; 
    Judgement.Equals.pp fmt (to_set());
    Format.fprintf fmt "@]@;"

  let find x =
    try 
      let e = Map.find x !state.tableau in 
	assert(tableau e);
	cod e
    with 
	Not_found -> x
	
  let apply x = 
    assert(is_var x);
    if is_slack x then
      let e = Map.find x !state.tableau in
	assert(tableau e);
	dom e, e
    else
      raise Not_found

  module Dep = struct
    let find x = Dep.find !state.dep_t x
    let rem x y = Dep.remove x y !state.dep_t
    let add x y = Dep.add x y !state.dep_t
    let is_empty x = try Dep.Set.is_empty (find x) with Not_found -> true
    module Set = Dep.Set
    let iter v f =
      assert(is_var v);
      try
	let dv = find v in
	  Set.iter
	    (fun u -> 
	       try f (Map.find u !state.tableau) with Not_found -> 
		 invalid_arg "imprecise dependency")
	    dv
      with
	  Not_found -> ()
  end

  exception Found of Judgement.equal
  let inv t =
    if is_var t || is_num t then raise Not_found else
      try
	Dep.iter (Term.choose is_var t)
	  (fun e -> if Term.eq t e#rhs then raise(Found(e)));
	raise Not_found
      with
	  Found(e) -> dom e, e

  (** Basic assignment by setting all independent variables to zero. *)
  let basic () = 
    let alpha = ref Term.Assign.empty in
    let add1 x n = (alpha := Term.Assign.add x n !alpha) in
    let add e = 
      let x = dom e and t = cod e in
	add1 x (A.mk_num (A.constant_of t));
	Term.iter (fun y -> add1 y (A.mk_zero())) t
    in
      iter add    
      
  let occurs x =
    assert(is_slack x);
    is_dependent x || not(Dep.is_empty x)
  
  let invariant () =
    Map.for_all 
      (fun _ e -> Dep.is_empty (dom e) && tableau e) 
      !state.tableau


  (** Deduce variable equality [x = y] between restricted variables. *)
  let deduce e =
    let x = e#lhs and y = e#rhs in    (* [e |- x = y]. *)
      assert(is_slack x && is_slack y);
      assert(not(is_dependent x));
      R.fuse e;
      Map.remove x !state.slacks

  (** Remove [x = a] from solution set. *)
  let restrict x =
    assert(is_slack x);
    try
      let t, _ = apply x in
	unchanged := false;
	Map.remove x !state.tableau;
	Term.iter (Dep.rem x) t;
    with
	Not_found -> ()

  let rec fuse e =                
    assert(is_slack e#rhs && is_restricted e#lhs);
    assert(not(occ e#rhs e#lhs));
    let fuse1 e1 =                           (* [e1 |- x = a]. *)
      let e2 = J.mk_fuse e e1 in             (* [e2 |- x = a'] *) 
	assert(not(occ (dom e) (cod e2)));   (* with [a'] does not contain lhs of [e]. *)
	replace e1 e2
    in
      Dep.iter e#lhs fuse1;
      assert(invariant())

  (** Replace binding [x |-> a] by [x |-> a']. *)
  and replace e1 e2 =
    assert(tableau e1 && tableau e2);
    assert(Term.eq (dom e1) (dom e2));
    assert(not(Term.eq (cod e1) (cod e2)));
    let x = dom e1 and a = cod e1 in    (* [e1 |- x = a[y]]. *)
    let a' = cod e1 in                  (* [e2 |- x = a'].   *)
      assert(occ (dom e2) (cod e1));
      if is_var a' then 
	(restrict x; deduce e2)
      else
	(try
	   let e3 = snd(inv a') in      (* [e3 |- y = a']. *)
	   let e4 = J.mk_join e2 e3 in  (* ==> [join e2 e3 |- x = y]. *)
	     restrict x; deduce e4
	 with
	     Not_found ->
	       unchanged := false;
	       Map.set x e2 !state.tableau;  
	       Effect.call x;
	       update_dependencies x a a')

  (** First, remove variables in [a] but not in [a'] from deps. 
    Second, add new variables from [a'] to deps. *)
  and update_dependencies x t t' = 
    let rem z = if not(Term.is_var_of z t') then Dep.rem x z in
      Term.iter rem t;   
      Term.iter (Dep.add x) t'

  let rec compose e =
    assert(not(occurs (dom e)));
    fuse e;
    if is_var (cod e) then deduce e else 
      if A.is_num (cod e) then constant e else 
	extend e;
    assert(invariant())

  (** Constant equalities [x = q] are just propagated to the unrestricted
    part when [x] does not occur in the tableau.*)
  and constant e = 
    assert(is_slack e#lhs && is_num e#rhs);
    assert(not(occurs e#lhs));
    let x = e#lhs and q = A.d_num e#rhs in            (* [e |- x = q]. *)
      if Q.is_neg q then          
	raise(Judgement.Unsat
		(J.mk_contra
		   (Explain.slack x)                 (* [n |- x >= 0]. *)
		   (J.mk_constant_pos (Q.minus q)))) (* [p |- -q > 0], for [q < 0]. *)
      else
	(restrict x; R.fuse e)

  and extend e =  
    assert(tableau e);
    let u = dom e in
      Map.set u e !state.tableau;
      Effect.call u;
      Term.iter (Dep.add u) u;
      unchanged := false

  exception Inf 

  (** The gain [gain u v] is 
    - [-c/q] if [u = c + ... + q*v + ...] with [q < 0] in tableau.
    - [Inf] otherwise. *)
  let gain (u, v) =
    assert(is_dependent u && occ v (find u));
    let t = find u in
    let q = A.coefficient_of v t in
      if Q.is_neg q then
	Q.minus (Q.div (A.constant_of t) q)
      else 
	raise Inf

  (** A pair [(u, v)] is pivotable if  [u = t[v]] is in tableau,
    the gain of [(u, v)] is finite and minimal among all gains [(u, v')]
    with [v'] in [t]. *)
  let rec is_pivotable (u, v) =
    is_dependent u && is_independent v && is_mingain (u, v)

  and is_mingain (u, v) = 
    try
      let g0 = gain (u, v) in
      let t, _ = apply u in
	M.for_all M.Neg
	  (fun v' -> 
	     (try Q.ge (gain (u, v')) g0 with Inf -> true))
	  t
    with
      | Inf -> false
      | Not_found -> false

  let pivot (u, v) =
    assert(is_pivotable (u, v));   (* in particular, [u = t[v]] in tableau. *)
    try
      let t, e = apply u in        (* [e |- u = t]. *)
	assert(occ v t);
	let e' = J.mk_pivot v e in (* ==> [e' |- v = t']. *)
	  fuse e';
	  restrict u;
	  extend e';
	  assert(invariant());
    with
	Not_found -> invalid_arg "Failed pivoting"
	  
  (** A restricted variable [v] is unbounded in 
    tableau [t] if it only occurs positively. *)
  let is_unbounded_var v =
    assert(is_slack v);
    try
      let depv = Dep.find v in
	Dep.Set.for_all
	  (fun u ->
	     try
	       let t = fst(apply u) in
		 assert(occ v t);
		 Q.is_pos (A.coefficient_of v t)
	     with
		 Not_found -> true)
	  depv
    with
	Not_found -> true

  (** A term [t] is unbounded if it contains an unbounded variable. *)
  let is_unbounded t =
    assert(is_restricted t);
    let unbounded m = is_unbounded_var (A.var_of m) in
      M.exists M.All unbounded t
	
  let is_not_unbounded t =
    not(is_unbounded t)

  exception Found of Term.t

  (** Choose an unbounded variable [x] in [t]. *)
  let choose_unbounded t =
    let choose m = 
      let x = A.var_of m in
	if is_unbounded_var x then raise(Found(x)) 
    in
      try 
	Term.iter choose t; raise Not_found
      with
	  Found(x) -> x

  exception Pivot of Term.t * Term.t
  exception NotPivotable
 
  (** Choose smallest [u] and [v] with [v] in [vars(t+)] 
    such that [pivotable (u, v)] holds. *)
  let choose_pivot tag t =
    assert(is_restricted t);
    assert(not(is_unbounded t));
    try
      M.iter tag
	(fun v ->
	   (try
	      let dv = Dep.find v in
		Dep.Set.iter
		  (fun u ->   
		     if is_pivotable (u, v) then
	               raise(Pivot(u, v)))
		  dv
	    with
		Not_found -> ()))
	t;
      raise NotPivotable
    with
	Pivot(u, v) -> (u, v)
	  
  let replace t =
    let lookup u = snd(apply u) in
      J.mk_replace lookup t

  (** Result [t] is either unbounded or maximized at [|t|]. *)
  let max t0 =
    let rec maximize e =                  
      let t = e#rhs in                      (* [e |- t0 = t]. *)
	if is_unbounded t then e else
	  try
	    let u_v = choose_pivot Monomials.Pos t in
	      pivot u_v;
	      let e1 = replace t in         (* [e1 |- t = t1]. *)
		maximize (J.mk_trans e e1)  (* ==> [trans e e1 |- t0 = t1]. *)
	  with                              
	      NotPivotable -> e
    in
    let e = maximize (J.mk_refl t0) in
      assert(is_unbounded e#lhs || is_maximized e#lhs);
      e

  let min t =
    assert(is_pure t);
    let e = max (A.mk_neg t) in
    let t' = e#rhs in              (* [e |- -t = t']. *)
      J.mk_equiv e t (A.mk_neg t') (* ==> [e' |- t = -t']. *)

  exception Unbounded

  let sup t =
    assert(is_restricted t);
    let e = max t in
    let t' = e#rhs in                     (* [e |- t = t']. *)
      if is_maximized t' then
	let u = A.constant_of t' in
	let n' = Explain.maximized t' in  (* [n' |- u - t' >= 0]. *)
	  u, failwith "simplex.sup: to do"                
      else 
	raise Unbounded

  let inf t =
    assert(is_pure t);
    let e = min t in
    let t' = e#rhs in                    (* [e |- t = t']. *)
      if is_minimized t' then
	let l = A.constant_of t' in
	let n' = Explain.minimized t' in (* [n' |- t' - l >= 0]. *)
	  l, failwith "simplex.inf: to do"
      else 
	raise Unbounded
      
  (** Variant of [max] that stops as soon as [|t| > 0]. *)
  let max0 t0 = 
    let rec maximize e =                  (* [e |- t0 = t]. *)
      let t = e#rhs in 
	if Q.is_pos (A.constant_of t) || is_unbounded t then e else
	  (try
	     let uv = choose_pivot Monomials.Pos t in
	       pivot uv;
	       let e' = replace t in      (* [e' |- t = t']. *)
		 maximize (Judgement.mk_trans e e')
	   with
	       NotPivotable -> e)
    in 
    let e = maximize (J.mk_refl t0) in
      assert(Q.is_pos(A.constant_of e#rhs) || is_unbounded e#rhs || is_maximized e#rhs);
      e

  (** Iterate over all homogeneous tableau entries [x = t], 
    that is, constant [|t| = 0]. *) 
  let iter0 f =
    let f' e = if is_homogeneous e#rhs then f e in
      iter f'

  (** Smallest set of independent variables in [t] such that [vj in V0] iff 
    - there is some tableau entry [u =c1*v1 +...+cj*vj+...+ cn*vn] with [cj <0], and 
    - for all [j'] such that [cj' > 0], it is the case that [vj' in V0]. *)
  let v0 () =
    let v0 = Set.empty() in
      iter0                     (* 1. [V0_0 = { v | (u = t) in T, v in t-}. *)
	(fun e0 -> 
	   M.iter M.Neg (fun v -> Set.add v v0) (cod e0));
      let changed = ref false in
	while not !changed do   (* 2. [V0_m+1 = V0_m \ { vj in V0_m | (u = t) in T, *)
	  changed := true;      (*                        exists vj' in t+ s.t. vj' notin V0_m }] *)
	  Set.iter
	    (fun vj -> 
	       Dep.iter vj
	         (fun e0 -> 
		    assert(Q.is_neg (A.coefficient_of vj (cod e0)));
		    if M.exists M.Pos (fun vj' -> not(Set.mem vj' v0)) (cod e0) then
		      (changed := false; Set.remove vj v0)))
	    v0
	done;
	v0

  (** From [V0] we compute [X0] to be [V0] union [{u | vars(T(u)) subset V0}]. 
    It is the case that [{v | T => v = 0}] is a subset of [X0]. *)
  let x0 () =
    let v0 = v0 () in
    let mem v = Set.mem v v0 in
    let add u = Set.add u v0 in
      iter
	(fun e ->   
	   let u = dom e and t = cod e in
	     if Q.is_zero (A.constant_of t) then
	       if M.for_all M.All mem t then add u);
      v0

  let rec infer () =  
    propagate (x0 ())
      
  and propagate x0 =
    let variables_in_x0 =
      let in_x0 y = Set.mem y x0 in
	Term.for_all in_x0
    in  
      iter0
	(fun e ->
	   let u = dom e and t = cod e in            (* [e |- u = t] with [|t|=0]. *)
	     if variables_in_x0 t then
	       let e' = max0 t in            
	       let t' = e'#rhs in                    (* [e' |- t = t']. *)
		 if is_maximized_at Q.zero t' then
		   let n1 = Explain.maximized t' in  (* [n1 |- -t' >= 0]. *)
		   let n2 = J.mk_replace_in_nonneg   (* [n2 |- t' >= 0]. *)
			      (J.mk_trans e e') (Explain.slack u) 
		   in
		   let e0 = J.mk_deduce0 n2 n1 in    (* [e0 |- t' = 0]. *)
		     M.iter M.Neg                    
		       (fun v ->                     (* [e' |- v = 0]. *)  
			  let e' = J.mk_independent e0 v in
			    R.fuse e'; compose e')
		       t')
end 

(** Return equality [e] with [e |- x = t]. *)
let lookup x =
  if is_slack x then snd(T.apply x) else snd(R.apply x)
    
let apply x = 
  if is_var x then
    try R.apply x with Not_found -> T.apply x
  else
    raise Not_found

let find x =
  try apply x with Not_found -> (x, Judgement.mk_refl x)

let inv t = R.inv t

let is_dependent x =
  assert(is_var x);
  R.is_dependent x || 
  (is_slack x && T.is_dependent x)

let occurs x =
  assert(is_var x);
  R.occurs x || 
  (is_slack x && T.occurs x)

let var_of_pure t =          
  assert(is_pure t);
  if is_var t then t, J.mk_refl t else
    try R.inv t with Not_found -> 
      (try T.inv t with Not_found -> 
	 let x = Term.mk_fresh_var "v" in
	 let e = J.mk_alias x t in
	   R.extend e;
	   x, e)

(** Replacing dependent variables with corresponding right-hand sides. *)
let replace t =
  assert(is_pure t);
  J.mk_replace lookup t


module Process = struct 

  (** Processing a nonnegativity constraint [rho |- a >= 0].
    [a] is first minimized to detect implied constraints. Consequently,
    the state is not updated for such implied constraints. *)
  let rec nonneg n = 
    let n = J.mk_transform_nonneg replace n in
    let t = n#arg in                   (* [n |- t >= 0]. *)
      if is_restricted t then
	let e = T.min t in             (* [e |- t = t']. *)
	let t' = e#rhs in
	  if is_minimized_above_or_equal_to_zero t' then () else
	    let n' = J.mk_replace_in_nonneg e n in
	      assert(T.is_unbounded t');  (* ==> [n' |- t' >= 0]. *)
	      nonneg1 n'     
      else 
	nonneg1 n
	  
  and nonneg1 n =
    let w = mk_fresh_slack "k" n in 
      add_ineq (J.mk_alias w n#arg)
	
  and add_ineq e = (* [e |- w = a] with [w] fresh. *)
    let w = e#lhs and a = e#rhs in  
      assert(not(T.occurs e#lhs));
      try                         (* Unrestricted. *)
	let y = choose_unrestricted e#rhs in  
	  R.compose (J.mk_isolate y e)
      with                          (* Restricted. *)
	  Not_found -> 
	    add_ineq_restricted e

  and add_ineq_restricted e = 
    let w = e#lhs and t = e#rhs in                (* [e |- w = t]. *)
      assert(is_restricted t); 
      let q = A.constant_of t in
	if Mpa.Q.is_nonneg q && is_minimized t then   (* Minimize. *)
	  ()                                      
	else if is_maximized_below_zero t then        (* Maximize. *)
	  let p = Explain.maximized_below_zero t in (* [p |- -t>0] *)
	  let n = J.mk_replace_in_nonneg e (Explain.slack w) in
	    raise(Judgement.Unsat(J.mk_contra2 p n)) (* [n |- t>=0]*)
	else if Mpa.Q.is_nonneg q then                (* Feasible. *)     
	  T.compose e                         
	else  
	  try
	    let v = T.choose_unbounded t in          (* Unbounded. *)
	      T.compose (J.mk_isolate v e)
	  with
	      Not_found ->
		(try
		   let uv = T.choose_pivot Monomials.Pos t in
		     T.pivot uv;
		     let e' = T.replace t in     (* [e' |- t = t']. *)
		     let e'' = J.mk_trans e e' in
		       add_ineq_restricted e''  (* [e'' |- w = t']. *)
		 with
		     T.NotPivotable -> invalid_arg "Unreachable")
		
  (** Processing equalities [e |- t1 = t2]. *)
  let rec equal e = 
    equal0 (J.mk_equal0 e)
      
  and equal0 e =       
    assert(A.is_zero e#rhs);
    let e = J.mk_transform_equal replace e in 
    let t = e#lhs in                            (* [e |- t = 0] *)
      assert(A.is_zero e#rhs);
      try
	let q = A.d_num t in
	  if Q.is_zero q then () else
	    raise(Judgement.Unsat(
		    (J.mk_contra2 e (J.mk_constant_diseq q))))
      with
	  Not_found -> 
	    try                                (* Unrestricted. *)
	      let y = choose_unrestricted t in
		R.compose (J.mk_isolate y e)
	    with
		Not_found ->                     (* Restricted. *)
		  assert(is_restricted t);
		  let e0 =                    
		    if Q.is_nonpos (A.constant_of t) then e else 
		      J.mk_equiv e (A.mk_neg t) (A.mk_zero())
		  in
		  let t0 = e0#lhs in          (* [e0 |- t0 = 0]. *)
		  let n0 = J.mk_weaken e0 in  (* [n0 |- t0 >= 0]. *)
		  let z = mk_fresh_slack "z" n0 in
		    add_equal e0 (J.mk_alias z t0); 
		    assert(not(T.occurs z))
		      
  and add_equal e0 e =                         (* [e0 |- t0 = 0]. *)
    let z0 = e#lhs and t0 = e#rhs in           (* [e |- z0 = t0]. *)
    let q = A.constant_of t0 in
      if Q.is_zero q then                                  (* Eq0 *)
	(try
	   let v = M.choose t0 in
	     T.compose (J.mk_solve_for v e)
	 with
	     Not_found -> assert(A.is_zero t0); ())
      else if is_maximized_below_zero t0 then            (* EqMax *)
	let p = Explain.maximized_below_zero t0 in(* [p |- -t0>0] *)
	  raise(Judgement.Unsat(J.mk_contra2 e0 p))
      else if is_minimized_above_zero t0 then            (* EqMin *)
	let p = Explain.minimized_above_zero t0 in (* [p |- t0>0] *)
	  raise(Judgement.Unsat(J.mk_contra2 e0 p))
      else if Q.is_neg q then
	try
	  let v = T.choose_unbounded t0 in           (* Unbounded *)
	    T.compose (J.mk_solve_for v e)
	with
	    Not_found ->
	      try
		let uv = T.choose_pivot Monomials.Pos t0 in
		  T.pivot uv                           (* PivotUp *)
	      with
		  T.NotPivotable ->
		    assert(is_maximized_below_zero t0);  
		    let p0 = Explain.maximized_below_zero t0 in
		      raise(Judgement.Unsat(J.mk_contra2 e0 p0))
      else 
	begin
	  assert(Q.is_pos q);
	  try                                         (* PivotDown *)
	    let ((_, v) as uv) = T.choose_pivot M.Neg t0 in  
	      if T.gain uv < Q.div (Q.minus q) (A.coefficient_of v t0) then
		begin
		  T.pivot uv;
		  let e' = J.mk_transform_rhs_equal T.replace e in
		    add_equal e0 e'           (* [e' |- z0 = t0']. *)
		end 
	      else                                        (* Swap. *)
		T.compose (J.mk_solve_for v e)
	  with
	      Not_found ->
		assert(is_minimized_above_zero t0);
		let p0 = Explain.minimized_above_zero t0 in
		  raise(Judgement.Unsat(J.mk_contra2 e0 p0))		 
	end
	
	
  (** {6 Processing Positivity Constraints} *)
	
  let rec pos p =
    let p = J.mk_transform_pos replace p in
    let t = p#arg in                    (* [p |- t > 0]. *)
      if is_restricted t then  
	let e = T.min t in             (* [e |- t = t']. *)
	  if is_minimized_above_zero e#rhs then () else
	    let p' = J.mk_replace_in_pos e p in
	      assert(T.is_unbounded e#rhs); 
	      pos1 p'     (* ==> [p' |- t' > 0]. *)
      else 
	pos1 p
	  
  and pos1 p =
    nonneg (J.pos_to_nonneg p);
    diseq (J.pos_to_diseq p)
      
      
  (** {6 Processing Disequalities} *)
      
  (** Processing disequalities only deals with integer disequalities,
    which are maintained in the form [e <> n] where [n] is a natural 
    number. *) 
  and diseq d = 
    let d = J.mk_transform_diseq replace d in
      if Term.eq d#lhs d#rhs then
	raise(Judgement.Unsat(Judgement.mk_bot d))
      else if A.is_diseq d#lhs d#rhs then
	()
      else 
	diseq1 d
	  
  and diseq1 d =
    let d = J.mk_diseq0 d in (* [d |- t = 0]. *)
    let t = d#lhs in
      if is_restricted t then
	if is_diophantine t then 
	  diophantine_diseq d
	else 
	  nondiophantine_diseq d
      else 
	nondiophantine_diseq d

  and nondiophantine_diseq d =         (* [d |- t <> 0]. *)
    assert(A.is_zero d#rhs);
    let x, e1 = var_of_pure d#lhs              (* [e1 |- x = t]. *)
    and z, e2 = R.var_of_num Q.zero in         (* [e2 |- z = 0]. *)
    let d' = J.mk_replace_in_diseq (J.mk_sym e1) (J.mk_sym e2) d in
      V.Infsys.process_diseq d'                (* [d' |- x <> z]. *)

  (** Process [a <> 0] for [a] diophantine by processing 
    the disjunction [a >= 1] or [-a >= 1] when [a] is
    bounded from below by [l1+1] and above by [-l2-1]. 
    In particular, there are [l1], [l2] with 
    [a - 1 >= l1] and [-a - 1 >= l2]. Now, 
    the original disequality is encoded by
    - [a - 1 >= l1 * (1 - z) = l1 - l1 * z]
    - [-a - 1 >= l2 * z]
    - [0 <= z <= 1] with [z] a fresh integer variable.
    When [z] is [0] then [a - 1 >= l1], [-a - 1 >= 0],
    and when [z] is [1] then [a - 1 >= 0] and [-a - 1 >= l2]. *)
  and diophantine_diseq d =      (* [rho |- a <> 0 ]. *)
    assert(A.is_zero d#rhs);
    assert(is_diophantine d#lhs && is_restricted d#lhs);
    nondiophantine_diseq d
      (*
	let t_sub1 = A.mk_decr t in
	let nega_sub_1 =  A.mk_decr (A.mk_neg t) in
	if is_maximized_below_zero a_sub_1 then
	let n = failwith "simplex: to do" in   (* ==> [rho, tau |- -a-1 >= 0 <=> a <> 0]. *)
        nonneg (nega_sub_1, Jst.dep2 rho tau)
	else if is_maximized_below_zero nega_sub_1 then
	let n = failwith "simplex: to do" in  (* ==> [rho, sigma |- a - 1 >= 0 <=> a <> 0]. *)       
        nonneg n
	else 
	(try
        let l1, tau = T.inf a_sub_1 in                (* [tau |- a-1 >= l1]. *)
        let l2, sigma = T.inf nega_sub_1 in           (* [sigma |- -a-1 >= l2]. *)
        let theta = Jst.dep3 rho tau sigma in
        let z = mk_fresh_slack "b" Jst.dep0 in
        ge (a_sub_1, A.mk_addq l1 (A.mk_multq (Q.minus l1) z), theta);
        ge (nega_sub_1, A.mk_multq l2 z, theta);
        le (z, A.mk_one(), theta)
        with
        T.Unbounded -> 
        add_nondiophantine_diseq d)
      *)


  (** {6 Normalize Integer Disequalities} *)
      
  let normalize_diophantine_disequalities () =
    failwith "simplex.norm: to do"

      
  (** {6 Gomory Cuts} *)
      
  let cut e =                      
    assert(T.tableau e);
    let x = T.dom e and t = T.cod e in (* [e |- x = t]. *)
      assert(is_slack x && is_restricted t);
      assert(is_diophantine x && is_diophantine t);
      if Q.is_integer (A.constant_of t) then raise Not_found else   
	nonneg
	  (J.mk_gomory e
	     (Explain.slack x)
	     (Explain.diophantine t)
	     (Explain.restricted x)
	     (Explain.restricted t))
   
  let rec gomory1 e = 
    assert(T.tableau e);
    let x = T.dom e and t = T.dom e in    (* [e |- x = t]. *)
      if not(Q.is_integer (A.constant_of t)) &&
	is_diophantine x && 
	is_diophantine t
      then
	try cut e with Not_found -> (* Left cut. *)
	  let q = A.constant_of t in
	    M.iter M.Neg 
	      (fun m -> 
		 let qi = A.coeff_of m in
		   if not (Q.is_integer (Q.div q qi)) then
		     let xi = A.var_of m in
		       try cut (J.mk_isolate xi e) with Not_found -> ())
	      t
	      
  let gomory () =
    T.iter gomory1


  let rec toplevel f a =
    let b = f a in
      fuse_across ();
      T.infer ();
      gomory ();
      b

  and fuse_across () =
    T.iter 
      (fun e -> 
	 if R.occurs_in_cod (T.dom e) then R.fuse e)

end
      

(** {6 Model Construction} *)

module Assignment = struct

  (** Set dependent variables to [0]. *)
  let alpha_init () =
    let alpha = Map.empty() in
    let set0 e = 
      Term.iter (fun y -> Map.set y Mpa.Q.zero alpha) e#rhs
    in
      T.iter set0;
      R.iter set0;   (* assumes all slacks are propagated. *)
      alpha

  (** Build corresponding term interpretation. *)
  let to_term alpha =
    Map.fold
      (fun x q -> 
	 Term.Assign.add x (A.mk_num q))
      alpha
      Term.Assign.empty

  (** Variable ordering such that unrestricted variables 
    preceed the restricted ones. *)
  let varcmp x y =
    if Term.eq x y then 0 else 
      match is_slack x, is_slack y with
	| false, true -> -1
	| true, false -> 1
	| _ -> Term.compare x y

  (** Solve for minimal variable. *)
  let minsolve (a, b) = 
    let e = A.mk_sub a b in
    let z0 = M.choose_min varcmp e in
    let e' = A.qsolve_for z0 e in
      (z0, e')

  (** Disequalities [rho{1} |- x <> e1], ..., [rho{n} |- x <> n] represented
    as maps [x |-> [e1, ...,en)] *)
  module D = Maps.Make(struct
      type t = Term.t
      let compare = varcmp
      let pp = Term.pp
  end)
    
  (** Evaluate [a] in the context of the [alpha]. Notice that [alpha] is
    only defined on dependent variables and [a] might contain dependent
    variables [x]. *)
  let rec eval alpha a =
    let rec value_of_var x = 
      Trace.msg 8 "value_of_var" x Term.pp;
      assert(is_var x);
      try 
	let b, _ = R.apply x in
	  value_of_pure b
      with
	  Not_found ->
	    (try
	       let b, _ = T.apply x in
		 value_of_pure b
	     with 
		 Not_found -> 
		   try 
		     Map.find x alpha 
		   with
		       Not_found -> invalid_arg "Partial assignment")
    and value_of_pure a =
      assert(is_pure a);
      A.eval value_of_var a
    in
      try
	value_of_pure a       (* replace *)
      with 
	  Not_found -> invalid_arg "partial interpretation"
	
  let is_equal alpha a b =
    Q.equal (eval alpha a) (eval alpha b)
        
  (** Choose [x] such that [x <> e] in [d] with [eval alpha x] 
    equal to [eval alpha e]. *)
  let choose alpha d =
    let max = ref ((Obj.magic 0) : Term.t) in
    let found = ref false in
      D.iter
	(fun x el -> 
	   if List.exists (is_equal alpha x) el then
	     if !found && varcmp x !max > 0 then 
	       max := x
	     else 
	       (max := x; found := true))
	d;
      if !found then !max else raise Not_found

  module Qset = Sets.Make(
    struct
      type t = Q.t
      let compare = Q.compare
      let pp = Q.pp
    end)

  let q (alpha, d) x =
    let qs = Qset.empty () in 
      try
	let el = D.find x d in
	  List.iter
	    (fun e -> Qset.add (eval alpha e) qs)
	    el;
	  qs
      with
	  Not_found -> qs
	    
  (** Disequalities of the form [x <> e], where [x] is smaller than
    any variable in [e] with respect to ordering [varcmp]. *)
  let diseqs () = failwith "simplex.diseqs: to do"
(*
    let d = D.empty () in
      V.Iter.on_diseqs
	(fun x y  -> 
	   let a, _ = find x and b, _ = find y in
	     if not(x == a && y == b) then
	       let (z, e') = minsolve (a, b) in
		 try
		   let dz = D.find z d in
		     D.set z (e' :: dz)  d
		 with
		     Not_found -> D.set z [e'] d)
	(V.Infsys.current());
      d
*)

  let fuse x q ds = failwith "simplex.fuse: to do"
(*
    D.iter
      (fun y el -> 
	 if List.exists (Term.occurs x) el then
	   let el' = Term.mapl (Term.replace x (A.mk_num q)) el in
	     D.set y el' ds)
      ds
*)
    
  let rec build () =
    let alpha = alpha_init () in
    let ds = diseqs () in
    let rec repair () = 
      try
	let x = choose alpha ds in
	let qs = q (alpha, ds) x in
	assert(not(Qset.is_empty qs));
	let q0 = 
	  if is_unrestricted_var x then
	    if Qset.cardinal qs = 1 then
	      Q.div (Qset.choose qs) Q.two
	    else  
	      let q' = Qset.choose qs in
		Qset.remove q' qs;
		let q'' = Qset.choose qs in
		  Q.div (Q.add q' q'') Q.two 
	  else 
	    try
	      let sup, _ = maximize x in  (* [x <= max]. *)
              assert(Q.is_pos sup);
	      Qset.remove Q.zero qs;
	      let min = try Q.min sup (Qset.min_elt qs) with Not_found -> sup in
		assert(Q.is_pos min);
		Q.div min Q.two
	    with
		T.Unbounded -> 
		  let min = Qset.min_elt qs in
		    (* assert(Q.is_pos min); *)
		    Q.div min Q.two
	in
	  Map.set x q0 alpha;
	  D.remove x ds;
	  repair ()
      with
	  Not_found -> () 
    in
      repair ();
      totalize alpha

  and totalize alpha =
    let extend e =
      let x = e#lhs and a = e#rhs in
      let v = eval alpha a in
	Map.set x v alpha
    in
      R.iter extend;
      T.iter extend;
      alpha

  and maximize x =
    protect T.sup x


end

module Config = struct

  type eqs = t

  type t = eqs

  let empty = empty

  (** Call a side-effect free function [f] on argument [a]. *)
  let with_config s0 f t =
    let save = !state in
      try state := s0; let t' = f t in state := save; t' with exc -> 
	state := save; raise exc
	  
  let with_protected_config s0 f t =
    let save = copy !state in
      try state := s0; let t' = f t in state := save; t' with exc -> 
	state := save; raise exc

  let is_empty s =
    let emptiness s = T.is_empty s && R.is_empty s in
      with_config s emptiness ()

  let rec pp fmt s = 
    if debug >= 3 then pp_debug fmt s else 
      let r = with_config s R.to_set () 
      and t = with_config s T.to_set () in
	if not(Map.is_empty s.regular) then 
	  Format.fprintf fmt "\nr:"; Judgement.Equals.pp fmt r;
	if not(Map.is_empty s.tableau) then 
	  (Format.fprintf fmt "\nt:"; Judgement.Equals.pp fmt t)
      
  and pp_debug fmt s =
    let pp_equal fmt e = e#pp fmt in
    let pp_nonneg fmt n = n#pp fmt in
      Format.fprintf fmt "r:"; Map.pp pp_equal fmt s.regular;
      Format.fprintf fmt "\nt:"; Map.pp pp_equal fmt s.tableau;
      Format.fprintf fmt "\nSlacks: "; Map.pp pp_nonneg fmt s.slacks;
      Format.fprintf fmt "\ndep(r): "; Dep.pp fmt s.dep_r;
      Format.fprintf fmt "\ndep(t): "; Dep.pp fmt s.dep_t
	
  let apply s x = failwith "simplex.apply: to do"
	
  let inv s a =
    let inverse a =
      try R.inv a with Not_found -> T.inv a 
    in
      with_config s inverse a

  let can s t =
    let repl t = 
      let e = replace t in
	e#rhs, e
    in
      with_config s repl t

  let is_canonical s t =
    failwith "simplex.is_canonical: to do"
	
  let dep s x =
    let dx_r = try Dep.find s.dep_r x with Not_found -> Dep.Set.empty() in
    let dx_t = try Dep.find s.dep_r x with Not_found -> Dep.Set.empty() in
    let dx_t = Dep.Set.copy dx_t in
      Dep.Set.union dx_r dx_t;
	dx_t

  let occ x s = 
    with_config s occurs x

  let model s =
    let interp = Term.Interp.empty (* A.sigma f a *) in
    let alpha = with_config s Assignment.build () in
      (interp, Assignment.to_term alpha)


  module Minimize = struct

    let term s t =
      assert(is_pure t);
      t

    let justify s t = J.mk_refl t

  end 
   

  let inf s t = 
    assert(is_pure t);
    let inf' t = 
      if is_restricted t && not(T.is_unbounded t) then
	try Some(T.inf t) with T.Unbounded -> None 
      else 
	None
    in
      with_protected_config s inf' t
	
  let sup s t =
    assert(is_pure t);
    let sup' a =  
      if is_restricted t && not(T.is_unbounded t) then
	try Some(T.sup a) with T.Unbounded -> None
      else 
	None
    in
      with_protected_config s sup' t

  let is_nonneg s t =
    let is_nonneg' t = 
      let e = replace t in
      let t' = e#rhs in
	if is_restricted t' && not(T.is_unbounded t') then
	  failwith "simplex.is_nonneg: to do"
    in
      with_protected_config s is_nonneg' t
	      
	
  let is_equal s t1 t2 =
    assert(is_pure t1 && is_pure t2);
    let is_equal' (t1, t2) = 
      let e1 = replace t1 and e2 = replace t2 in (* [e1 |- t1 = t1'], [e2 |- t2 = t2']. *)
      let t1' = e1#rhs and t2' = e2#rhs in     
	if Term.eq t1' t2' then
	  Some(J.mk_join e1 e2)
	else 
	  None
    in
      with_config s is_equal' (t1, t2)
	
  let is_maximized s a =
    assert(is_pure a);
    let is_max' a = 
      if is_maximized a then Some(Explain.maximized a) else None
    in
      with_config s is_max' a

  let is_minimized s a =
    assert(is_pure a);
    let is_min' a = 
      if is_minimized a then Some(Explain.minimized a) else None
    in
      with_config s is_min' a

  let is_nonzero s = failwith "simplex.is_nonzer: to do"
 
end


(** {6 Inference System} *)

module Infsys = struct

  let current () = !state
		  
  let initialize s0 =
    unchanged := true;
    state := s0

  let reset () =
    unchanged := true;
    state := (empty())
	
  let is_unchanged () = !unchanged
		     
  let finalize () =
    if !unchanged then !state else copy !state

  module Effect = Effect

  let abstract t a =
    assert(is_pure t);
    let e1 = replace t in             (* [e1 |- t = t']  *)
    let x, e2 = var_of_pure e1#rhs in (* [e2 |- x = t']. *)
      assert(Term.is_var x);
      let e = J.mk_join e1 e2 in      (* [e |- t = x]. *)
	G.Infsys.put (J.mk_replace_in_atom e a)

  let rec process_equal e =
    assert(is_pure e#lhs && is_pure e#rhs);  
    if not(Term.eq e#lhs e#rhs) then
      Process.toplevel Process.equal e

  let process_diseq d =  
    assert(is_pure d#lhs && is_pure d#rhs);
    Process.toplevel Process.diseq d

  let process_nonneg n = 
    assert(is_pure n#arg);
    Process.toplevel Process.nonneg n

  let process_pos p =
    assert(is_pure p#arg);
    Process.toplevel Process.pos p

  let alias = R.var_of_num
		
  let propagate_equal x =
    assert(is_var x && not(is_restricted x));
    if R.occurs x then
      let y, e1 = V.Infsys.can x in      (* [e1 |- x = y]. *)
	assert(not(Term.eq x y));
	assert(not(is_restricted y));
	(try
	   let t, e2 = R.apply x in      (* [e2 |- x = t] *)
	     R.restrict x;               (* [e3 |- y = t]. *)
	     let e3 = J.mk_trans (J.mk_sym e1) e2 in
	       Process.toplevel Process.equal e3
	 with
	     Not_found -> 
	       R.Dep.iter x
	         (fun e ->
		    let z = R.dom e and t = R.cod e in
		    if occ x t then
		      let e' = J.mk_fuse e1 e in
			R.restrict z;
			Process.toplevel Process.equal e'))
  
  let propagate_diseq d =
    let x = d#lhs and y = d#rhs in         (* [d |- x <> y]. *)
    assert(is_var x && is_var y);
    try
      let t1, e1 = apply x in             (* [e1 |- x = t1]. *)
	(try
	   let t2, e2 = apply y in        (* [e2 |- y = t2]. *)
	   let d' = J.mk_replace_in_diseq e1 e2 d in
	     if Term.eq t1 t2 then
	       raise(Judgement.Unsat(Judgement.mk_bot d'))
	     else
	       process_diseq d'
	 with
	     Not_found -> 
	       let d' = J.mk_replace_in_diseq (J.mk_refl y) e1 d in
		 process_diseq d')
    with
	Not_found -> 
	  (try
	     let t2, e2 = apply y in   
	     let d' = J.mk_replace_in_diseq (J.mk_refl x) e2 d in
	       process_diseq d'
	   with
	       Not_found -> ())

  let propagate_cnstrnt c =
    let x = c#arg and c = c#cnstrnt in
      assert(is_var x);
      match c with 
	| Cnstrnt.Int -> ()
	| _ -> ()
	
  let branch () = raise Not_found
	  
  let normalize () = ()

end

(** {6 Linear arithmetic component} *)

module Component = struct
  let th = Linarith.theory
  module Config = Config
  module Infsys = Infsys
end


