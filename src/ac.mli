(*
 * The contents of this file are subject to the ICS(TM) Community Research
 * License Version 2.0 (the ``License''); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.icansolve.com/license.html.  Software distributed under the
 * License is distributed on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing rights and limitations under the License.  The Licensed Software
 * is Copyright (c) SRI International 2003, 2004.  All rights reserved.
 * ``ICS'' is a trademark of SRI International, a California nonprofit public
 * benefit corporation.
 *)

(** Inference system for theories with single AC symbol

  @author Harald Ruess
  @author N. Shankar
*)

(** Specification of a signature [th] with one binary,
  {i associative-commutative} (AC) function symbol [f]. *)
module type SIG = sig
  val th : Theory.t
  val f : Funsym.t
end 


(** Specification of a theory with a single AC symbol by
  means of canonizers and ground completion functions. 
  The canonizers are obtained from [Make(Sig)] and the
  completion functions perform forward chaining on
  - [x' = z*u], [y = x*v], [x =v x'] ==> [y = z*u*v]. *)
module T(Sig: SIG) : sig
  val th : Theory.t
  val lhs : Term.t -> Term.t
  val rhs : Term.t -> Term.t
  val is_interp : Term.t -> bool
  val is_pure : Term.t -> bool
  val make : Term.t -> Term.t -> Term.t
  val pp : Format.formatter -> Funsym.t -> Term.t list -> unit
  val map : (Term.t -> Term.t) -> Term.t -> Term.t
  val sigma : Term.interp
  val chains : Axioms.Chain.t list
  val disjunction : Judgement.equal -> Judgement.disjunction
end


module Make(Sig: SIG): Can.COMPONENT
  (** Inference system for a theory with a single AC symbol.

    An {i AC context} consists of equalities of the form [x = y*z] 
    with [x], [y], [z] variables, with [*] an associative-commutative
    function symbol.
    
    The following invariants are maintained.
    - Right-hand sides of context equalities [x = a] are kept in 
    canonical form.  That is, if the variable equality [y = z]
    has been merged using [merge], then the noncanonical [y]
    is not appearing on any right-hand side. 
    - Also, if [x = a] and [y = b] in a context, then the 
    variables [x] and [y] are different (that is, they are not {!Term.eq})
    - If [u = y * v] in a context, then [y] is always {i atomic} in the 
    sense that it is an {i original} variable from one of the arguments
    of [process] or [name], whereas [u], [v] may be {i generated}
    variables.

    Forward chaining is used to keep contexts {i confluent}
    - [x' = y * v], [z = x*u], [x =v x'] ==> [z = y * v * u]
    with [=v] generated by the current variable partitioning. *)



