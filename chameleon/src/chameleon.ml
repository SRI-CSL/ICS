(*
 * The contents of this file are subject to the ICS(TM) Community Research
 * License Version 1.0 (the ``License''); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.icansolve.com/license.html.  Software distributed under the
 * License is distributed on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing rights and limitations under the License.  The Licensed Software
 * is Copyright (c) SRI International 2001, 2002.  All rights reserved.
 * ``ICS'' is a trademark of SRI International, a California nonprofit public
 * benefit corporation.
 * 
 * Author: Jean-Christophe Filliatre
 *)

(** Automatic C stub code generation for an ICS interface description. *)

open Filename
open Printf
open Str
open Mli_types
open Mli_lexer

(** Globals. *)
let base = ref ""
let cout = ref stdout
let hout = ref stdout
let lout = ref stdout
let mlout = ref stdout

let cprintf x = fprintf !cout x
let hprintf x = fprintf !hout x
let lprintf x = fprintf !lout x
let mlprintf x = fprintf !mlout x

(** [iter_lines] iters the function [f] over all the lines of file [file]. *)
let iter_lines f file =
  let c = open_in file in
    try
      while true do 
	f (input_line c) 
      done
    with 
	End_of_file -> close_in c


(** Table of declarations in [.mli] file. *)
module Decls = struct

  module D = Map.Make(
    struct 
      type t = string
      let compare = Pervasives.compare
    end)

  let decls = ref D.empty

  let build file =
    iter_lines
      (fun str -> 
	 try  
	   let (name, signature) = declaration_of_string str in
	     decls := D.add name signature !decls
	 with
	     Parsing.Parse_error -> ())
      (file ^ ".mli")

  let iter f = D.iter f !decls

  let cardinal () =
    let count = ref 0 in
      iter (fun _ _ -> incr count);
      !count

end

(** Apply [f i a] to [i]th element [a] in [l] and apply [sep] in an infix fashion. *)
let iter_args f sep l =
  let rec iter i = function
    | [] -> ()
    | [a] -> f i a
    | a::args -> f i a; sep (); iter (succ i) args
  in
    iter 1 l

let funname name = 
  sprintf "%s_%s" !base name

let argname i = "x" ^ string_of_int i

let rec output_c_code () =
  cprintf "/* THIS FILE IS AUTOMATICALLY GENERATED FROM $ICSHOME/src/ics.mli */\n";
  cprintf "\n#include <stdio.h>\n#include <string.h>\n";
  cprintf "#include <caml/mlvalues.h>\n#include <caml/alloc.h>\n";
  cprintf "#include <caml/callback.h>\n#include <caml/memory.h>\n";
  cprintf "extern void set_ocaml_handlers(void);\n";
  cprintf "extern void restore_lisp_handlers(void);\n";
  cprintf "extern void ics_error(char *, char *);\n"; 
  cprintf "typedef int ics_value;\n";
  cprintf "value* r = NULL;\n";
  cprintf "\n/* Values registered from Caml. */\n"; 
  Decls.iter 
    (fun name _ -> 
       cprintf "value* %s_rv;\n" (funname name));
  Decls.iter 
    (fun name signature ->
       let typ = Mli_types.to_string signature in
	 cprintf "\n/* %s : %s */\n" name typ;
	 output_c_stub name signature);
  cprintf "\n/* Caml startup. */\n\n";
  cprintf "int caml_started_p = 0;\n";
  cprintf "void %s_caml_startup() {\n" !base;
  cprintf " char ** a;\n";
  cprintf " if (caml_started_p) {\n";
  cprintf "  fprintf(stdout, \"### Caml already started\\n\");\n";
  cprintf "  return;\n";
  cprintf " }\n";
  cprintf " a = malloc(2*sizeof(char **));\n";
  cprintf " a[0] = malloc(4);\n";
  cprintf " a[0][0] = 'i';\n";
  cprintf " a[0][1] = 'c';\n";
  cprintf " a[0][2] = 's';\n";
  cprintf " a[0][3] = (char)NULL;\n";
  cprintf " a[1] = (char*)NULL;\n"; 
  cprintf " set_ocaml_handlers();\n";
  cprintf " caml_started_p = 1;\n";
  cprintf " fprintf(stderr, \"### Caml startup\\n\");\n";
  cprintf " fflush(stderr);\n";
  cprintf " caml_startup(a);\n";
  cprintf " r = malloc(sizeof(value));\n";
  cprintf " if (r == NULL) { fprintf(stderr, \"### aborted\\n\"); exit(1); };\n";
  cprintf " fprintf(stderr, \"### successful\\n\");\n";
  cprintf " fflush(stderr);\n"; 
  Decls.iter
    (fun name _ -> 
       cprintf " %s_rv = caml_named_value(\"%s\");\n" (funname name) name);
  cprintf " restore_lisp_handlers();\n";
  cprintf "}\n"

(** Output the C stub code. *)
and output_c_stub f signature = 
  output_c_proto !cout (f, signature);
  cprintf " {\n";
  cprintf "  set_ocaml_handlers();\n";
  cprintf "  *r = callback%s_exn(*%s_rv," (arity f signature) (funname f);
  (match signature.dom with
    | [] -> cprintf "Val_unit"
    | _ -> 
	iter_args 
	  (fun i a ->
	     let xi = argname i in
	       match a with
		 | Int -> cprintf "Val_int(%s)" xi
		 | Unit -> cprintf "Val_unit"
		 | Bool -> cprintf "Val_bool(%s)" xi
		 | String -> cprintf "copy_string(%s)" xi
		 | Value -> cprintf "Val_int((ics_value)%s)" xi)
	(fun () -> cprintf ", ")
	signature.dom);
  cprintf ");\n"; 
  cprintf "  restore_lisp_handlers();\n";
  cprintf "  if (!Is_exception_result(*r)) {";
  (match signature.cod with
     | Unit -> cprintf "return; "
     | Int -> cprintf "return (Int_val(*r));"
     | Bool -> cprintf "return (Bool_val(*r));"
     | String -> cprintf "return (strdup(String_val(*r)));"
     | Value -> cprintf "return (ics_value)(Int_val(*r));");
  cprintf "};\n";
  cprintf "  ics_error(\"%s\",format_caml_exception(Extract_exception(*r)));\n" (funname f);
  cprintf "  return (";
  output_c_result_type !cout signature.cod ;
  cprintf ")0;\n";
  cprintf "}\n"

and arity f signature = 
  match List.length signature.dom with
  | 0 -> ""
  | 1 -> ""
  | 2 -> "2"
  | 3 -> "3"
  | _ -> Format.eprintf "%s has too many arguments\n" f; exit 1

(** Output the C prototype of the function. *)
and output_c_proto ch (name, signature) =
  output_c_result_type ch signature.cod;
  fprintf ch " %s(" (funname name);
  output_c_arglist ch signature.dom;
  fprintf ch ")"

and  output_c_result_type ch = function
  | Int -> fprintf ch "int"
  | Bool -> fprintf ch "int"
  | Unit -> fprintf ch "void"
  | String -> fprintf ch "char* "
  | Value -> fprintf ch "ics_value"

and output_c_arglist ch dom =
  match dom with
    | [] -> ()
    | [Unit] -> ()
    | args -> 
	iter_args 
	(fun i a -> 
	   let xi = argname i in
	     match a with
	       | Int -> fprintf ch "int %s" xi
	       | Bool -> fprintf ch "int %s" xi
	       | Unit -> fprintf ch "void %s" xi
	       | String -> fprintf ch "char* %s" xi
	       | Value -> fprintf ch "ics_value %s" xi)
	(fun () -> fprintf ch ", ")
	args

let output_h_code () =
  hprintf "/* THIS FILE IS AUTOMATICALLY GENERATED FROM ics.mli */\n";
  hprintf "\ntypedef int ics_value;\n";
  hprintf "\nint %s_false();\n" !base;
  hprintf "\nint %s_true();\n" !base;
  hprintf "\nint %s_nil();\n" !base;
  Decls.iter 
    (fun name signature ->
       let typ = Mli_types.to_string signature in
	 hprintf "\n/* %s : %s */\n" name typ;
	 output_c_proto !hout (name, signature);
	 hprintf ";\n")


let rec output_lisp_code () =
  lprintf ";;; ICS Interface description for C/C++\n";
  lprintf ";;; Allegro Common Lisp Foreign Function Interface for ICS\n";
  lprintf ";;; THIS FILE IS AUTOMATICALLY GENERATED FROM ics.mli\n";
  lprintf "\n(make-package :ics)\n";
  lprintf "\n(defun %s_false () 0)\n" !base;
  lprintf "\n(defun %s_nil () 0)\n" !base;
  lprintf "\n(defun %s_true () 1)\n" !base;
  lprintf "(ff:def-foreign-call %s_caml_startup () :returning :void)" !base;
  Decls.iter 
    (fun name signature ->
       let typ = Mli_types.to_string signature in
	 lprintf "\n;; %s : %s\n" name typ;
	 output_lisp_stub name signature;
	 lprintf ";\n")

and output_lisp_stub f signature =
  lprintf "(ff:def-foreign-call %s_%s (" !base f;
  (match signature.dom with
      | [] -> lprintf ") "
      | [Unit] -> lprintf ") "
      | _ -> 
	    iter_args
	      (fun i a -> 
		 let xi = argname i in
		   (match a with
		      | Value | Int | Bool -> lprintf "%s" xi
		      | _ -> lprintf "(%s %s)" xi (lisp_type_of a)))
	      (fun () -> lprintf " ")
	      signature.dom;
	    lprintf ")");
  (match signature.cod with
    | Unit -> lprintf " :returning %s" (lisp_type_of Unit)
    | _ -> ());
  lprintf ")\n"

and lisp_type_of t =
  match t with
    | Int -> ":int"
    | Bool -> ":bool"
    | String -> "(* :char)"
    | Unit -> ":void"
    | Value -> ":int fixnum"


let output_ml_code () = 
 Decls.iter 
    (fun name signature ->
       let typ = Mli_types.to_string signature in
	 mlprintf "\n(* %s : %s *)" name typ;
	 mlprintf "\nlet _ = Callback.register \"%s\" %s\n" name name)

let open_out file = 
  cout := open_out (file ^ "_stub.c");
  hout := open_out (file ^ ".h");
  lout := open_out (file ^ ".lisp");
  mlout := open_out ("register.ml")

let close_out () = 
  close_out !cout;
  close_out !hout;
  close_out !lout;
  close_out !mlout
 
let main () =
  let file = chop_extension Sys.argv.(1) in
  Decls.build file;
  base := basename file;
  open_out file;
  output_h_code ();
  output_c_code ();
  output_lisp_code ();
  output_ml_code ();
  eprintf "\nRegistering %d API functions" (Decls.cardinal());
  close_out()
 
let _ = Printexc.catch main ()
