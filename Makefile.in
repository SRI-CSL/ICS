
### configuration part (done by ./configure) #################################

OCAMLSTDLIB = `ocamlc -v | tail -1 | cut -f 4 -d " "`

GMPPATH = -L/usr/lib
LIBGMPA = /usr/lib/libgmp.a
GMPINCLUDE = -I /usr/include

OCAMLC   = @OCAMLC@
OCAMLLINK= @OCAMLMKTOP@
OCAMLOPT = @OCAMLOPT@
OCAMLLEX = @OCAMLLEX@
OCAMLYACC= @OCAMLYACC@
OCAMLDEP = @OCAMLDEP@

HEVEA = @HEVEA@
OCAMLWEB = @OCAMLWEB@
OCAMLWEBSTY = $$HOME/tex/inputs/ocamlweb.sty

### end of configuration part ################################################



ifeq ($(MAKELEVEL),0)
	ARCH := $(shell bin/config.guess)
        export ARCH
	OBJDIR = ./obj/$(ARCH)
	BINDIR = ./bin/$(ARCH)
	LIBDIR = ./lib/$(ARCH)
	SRCDIR = ./src
	DOCDIR = ./doc
else
	OBJDIR = .
	BINDIR = ../../bin/$(ARCH)
	LIBDIR = ../../lib/$(ARCH)
	SRCDIR = ../../src
	DOCDIR = ../../doc
endif

# Flags

INCLUDE = # -I unify -I fol -I qe
CFLAGS = 
BFLAGS = -g $(INCLUDE) # -noassert
OFLAGS = $(INCLUDE) # -noassert
LIBS = -cclib "$(GMPPATH) -lunix -lgmp"

# Object files

COBJS = mlgmp.o

CMI = hashcons.cmi hasht.cmi ptset.cmi \
      ptmap.cmi tools.cmi seqs.cmi \
      gmp.cmi mpa.cmi bitv.cmi term.cmi \
      tset.cmi tmap.cmi pp.cmi bdd.cmi \
      euclid.cmi poly.cmi bool.cmi equal.cmi \
      arith.cmi ineq.cmi prop.cmi congstate.cmi \
      tuple.cmi arrays.cmi conc.cmi bv.cmi \
      sets.cmi solve.cmi can.cmi process.cmi ics.cmi

CMO = hashcons.cmo hasht.cmo ptset.cmo \
      ptmap.cmo tools.cmo seqs.cmo \
      gmp.cmo mpa.cmo bitv.cmo term.cmo \
      tset.cmo tmap.cmo pp.cmo bdd.cmo \
      euclid.cmo poly.cmo bool.cmo equal.cmo \
      arith.cmo ineq.cmo prop.cmo congstate.cmo \
      tuple.cmo arrays.cmo conc.cmo bv.cmo \
      sets.cmo morphisms.cmo solve.cmo \
      can.cmo process.cmo ics.cmo

CMX = $(CMO:.cmo=.cmx)

.PHONY : all all-chdir
all: $(OBJDIR) $(LIBDIR) $(BINDIR)
	$(MAKE) -C $(OBJDIR) -f ../../Makefile all-chdir

all-chdir: ics $(LIBDIR)/libics.so $(LIBDIR)/libics.a ics.byte
	@echo 
	@echo ICS Build complete
	@echo 


TOPCMO = $(CMO) cmd.cmo parser.cmo lexer.cmo main.cmo
TOPCMI = $(CMI) cmd.cmi parser.cmi 

TOPCMX = $(TOPCMO:.cmo=.cmx)

ics: $(COBJS) $(TOPCMI) $(TOPCMX)
	$(OCAMLOPT) $(OFLAGS) -o $(BINDIR)/$@ unix.cmxa $(TOPCMX) \
                    $(COBJS) $(LIBS)

ics.byte: $(COBJS) $(TOPCMI) $(TOPCMO)
	$(OCAMLLINK) -g -custom -o $(BINDIR)/$@ unix.cma $(TOPCMO) \
                    $(COBJS) $(LIBS)

OBJS = ics_all.o ics_stub.o ics_error.o mlgmp.o

ics_all.o: $(CMX)
	$(OCAMLOPT) -output-obj -o $@ unix.cmxa $(CMX)

$(LIBDIR)/libics.so: $(OBJS)
	gcc -shared -o $(LIBDIR)/libics.so $(OBJS) \
	  $(OCAMLSTDLIB)/libunix.a \
	  $(LIBGMPA) \
          $(OCAMLSTDLIB)/libasmrun.a

$(LIBDIR)/libics.a: $(OBJS)
	cp $(OCAMLSTDLIB)/libasmrun.a $(LIBDIR)/libics.a
	ar r $(LIBDIR)/libics.a $(OBJS)

ics_stub.c ics.h ics.lisp: ics.ml ics.mli ../../chameleon/$(ARCH)/chameleon
	../../chameleon/$(ARCH)/chameleon ics.ml

GENERATED = lexer.ml parser.mli parser.ml

# don't know what this one does
top: $(COBJS) $(CMO)
	ocamlmktop -o top -custom unix.cma $(CMO) $(COBJS) $(LIBS)

../../chameleon/$(ARCH)/chameleon:
	make -C ../../chameleon all

### Directories

$(BINDIR):	
	-umask 022; if test '!' -d $(BINDIR) ; then \
                      mkdir $(BINDIR); fi;

$(OBJDIR):
	-umask 022; if test '!' -d $(OBJDIR) ; then \
           mkdir $(OBJDIR); fi; 

$(LIBDIR):
	-umask 022; if test '!' -d $(LIBDIR) ; then \
           mkdir $(LIBDIR); fi; 
  
### Source file links

.PRECIOUS : $(OBJDIR)/%.ml $(OBJDIR)/%.mli $(OBJDIR)/%.mly 
.PRECIOUS : $(OBJDIR)/%.mll $(OBJDIR)/mlgmp.c
.PRECIOUS : $(OBJDIR)/ics-pvs.lisp $(OBJDIR)/ics_error.c


$(OBJDIR)/%.ml: $(SRCDIR)/%.ml
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)
	
$(OBJDIR)/%.mli: $(SRCDIR)/%.mli
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)
	
$(OBJDIR)/%.mly: $(SRCDIR)/%.mly
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)
	
$(OBJDIR)/%.mll: $(SRCDIR)/%.mll
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)
	
$(OBJDIR)/mlgmp.c: $(SRCDIR)/mlgmp.c
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)

$(OBJDIR)/ics_error.c: $(SRCDIR)/ics_error.c
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)

$(OBJDIR)/ics-pvs.lisp: $(SRCDIR)/ics-pvs.lisp
	@(cd $(OBJDIR) ; ln -sf $(SRCDIR)/$(@F) .)

### Automatic tests

bench:: consistent inconsistent benchmarks

check:: consistent inconsistent

consistent: ics
	@for f in `find tests/consistent/ -maxdepth 1 -type f -print`; do \
	echo -n $$f"..."; \
	$(BINDIR)/ics $$f > /dev/null; if [ $$? = 0 ]; then echo "Ok"; else \
          echo "Error! (Should be consistent)"; exit $$?; fi \
	done

inconsistent: ics
	@for f in `find tests/inconsistent/ -maxdepth 1 -type f -print`; do \
	echo -n $$f"..."; \
	$(BINDIR)/ics $$f > /dev/null; if [ $$? = 3 ]; then echo "Ok"; else \
          echo "Error! (Should be inconsistent)"; exit $$?; fi \
	done

BENCHFILES=linsys-005 linsys-006 linsys-007 linsys-008 linsys-009 linsys-010 \
	   linsys-011 linsys-012 linsys-013 linsys-014 linsys-015 \
           trans-100 trans-200 trans-300 trans-400 trans-500 trans-1000 \
           ineq-010 ineq-020 ineq-030 ineq-040 ineq-050 ineq-060 ineq-070

benchmarks: ics
	@for f in $(BENCHFILES); do \
	echo -n "bench file $$f..."; \
	time -f "user = %U system = %S" $(BINDIR)/ics tests/bench/$$f > /dev/null;\
	done

PROFFILE = tests/bench/linsys-010

profile:
	make clean
	make OFLAGS=-p ics
	$(BINDIR)/ics $(PROFFILE)
	gprof $(BINDIR)/ics gmon.out > profile.out

CPROFFILE = tests/bench/trans-1000

cprofile:
	make BFLAGS="" OCAMLC="ocamlcp -p fmt" OCAMLLINK="ocamlcp -p fmt" clean ics.byte
	$(BINDIR)/ics.byte $(CPROFFILE)
	make find.prof shostak.prof

### literate programming

OCAMLWEBARGS = $(DOC)/intro.tex \
               $(DOC)/ics.tex $(SRC)/ics.mli \
               $(DOC)/terms.tex $(SRC)term.mli \
               $(DOC)/algo.tex $(SRC)/find.mli $(SRC)/find.ml \
               $(SRC)/process.ml \
               $(DOC)/dp.tex \
               $(SRC)/poly.mli $(SRC)/poly.ml $(SRC)/ineq.mli \
               $(SRC)/ineq.ml \
               $(SRC)/state.mli $(SRC)/state.ml $(SRC)/dp.mli $(SRC)/dp.ml \
               $(DOC)/theo.tex $(SRC)/term.ml $(SRC)/arith.mli \
               $(SRC)/arith.ml $(SRC)/tuple.mli $(SRC)/tuple.ml \
               $(SRC)/arrays.mli $(SRC)/arrays.ml \
               $(DOC)/misc.tex $(SRC)/tools.mli $(SRC)/lexer.mli \
               $(SRC)/toplevel.ml

manual: $(DOC)/manual.ps  $(DOC)/manual.html
	cp  $(DOC)/manual.ps  $(DOC)/manual.html $$HOME/internal_html/ics

doc:  $(DOC)/doc.ps  $(DOC)/doc.html
	cp  $(DOC)/doc.ps  $(DOC)/doc.html $$HOME/internal_html/ics

$(DOC)/doc.dvi:  $(DOC)/doc.tex  $(DOC)/dep.ps

$(DOC)/doc.ps:  $(DOC)/doc.dvi  $(DOC)/dep.ps

$(DOC)/doc.tex: $(OCAMLWEBARGS) Makefile
	$(OCAMLWEB) -o $(DOC)/doc.tex $(OCAMLWEBARGS)

$(DOC)/doc.html: $(DOC)/doc.tex
	$(HEVEA) $(OCAMLWEBSTY) $(DOC)/doc.tex -o $(DOC)/doc.html

$(DOC)/dep.ps: $(CMO:.cmo=.ml)
	$(OCAMLDEP) $(CMO:.cmo=.ml) | ocamldot -lr | dot -Tps > $(DOC)/dep.ps

### Emacs tags

tags:
	find . -name "*.ml*" | sort -r | xargs \
        etags "--regex=/let[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/let[ \t]+rec[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/and[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/type[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/exception[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/val[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/module[ \t]+\([^ \t]+\)/\1/"

### Generic rules

.SUFFIXES: .ml .mli .cmi .cmo .cmx .mll .mly .prof .tex .dvi .ps .html

.tex.dvi:
	latex $< && latex $<

.dvi.ps: 
	dvips $< -o $@

.tex.html:
	$(HEVEA) $< -o $@

.c.o:
	$(OCAMLC) -c -ccopt "-o $@" $(GMPINCLUDE)  $<

.mli.cmi:
	$(OCAMLC) $(BFLAGS) -c $<

.ml.cmo:
	$(OCAMLC) $(BFLAGS) -c $<

.ml.cmx:
	$(OCAMLOPT) $(OFLAGS) -c $<

.mll.ml:
	$(OCAMLLEX) $<

.mll.mli:
	$(OCAMLLEX) $<

.mly.ml:
	$(OCAMLYACC) $<

.mly.mli:
	$(OCAMLYACC) $<

.ml.prof:
	ocamlprof $< > $@

.PHONY: clean

clean::
	rm -f $(BINDIR)/ics $(BINDIR)/ics.byte 
	rm -rf $(OBJDIR) $(LIBDIR)
	make -C chameleon clean

# Static dependencies for the generated files.   There are no
# strange dependencies in the  manually generated files, so don't 
# bother with depend.

lexer.ml:  lexer.mll
parser.mli parser.ml: parser.mly

