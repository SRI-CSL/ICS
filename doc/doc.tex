\documentclass[12pt]{article}

\usepackage{ocamlweb}
\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{url}
\usepackage{epsf}
\usepackage{verbatim}
\usepackage[chapter]{/homes/owre/tex/tocbibind}
\usepackage[bookmarks=true,hyperindex=true,colorlinks=true,backref=true,pagebackref=true]{hyperref}

\newcommand{\replace}[2]{#1[#2]}
\newcommand{\norm}[2]{\mathit{norm}(#1)(#2)}
\newcommand{\lookup}[2]{\mathit{lookup}(#1)(#2)}
\newcommand{\can}[2]{\mathit{can}(#1)(#2)}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\compose}[2]{#1; #2}
\newcommand{\refsec}[1]{\textbf{\ref{#1}}}
\newcommand{\fullrefsec}[1]{Section~\textbf{\ref{#1}} page~\pageref{#1}}
\newcommand{\arrlk}[2]{#1[#2]}
\newcommand{\arrup}[3]{#1[#2:=#3]}
\newcommand{\comm}{\textit{command}}
\newcommand{\term}{\textit{term}}
\newcommand{\var}{\textit{var}}
\newcommand{\cnstrnt}{\textit{cnstrnt}}
\newcommand{\atom}{\textit{atom}}
\newcommand{\prop}{\textit{proposition}}

\title{ICS Manual (Version 1.0)}

\author{The ICS group\\[0.3em]
  {\small Computer Science Laboratory, SRI International} \\[-0.2em]
  {\small 333 Ravenswood Avenue, Menlo Park, CA 94025, USA} \\[-0.2em]
  {\small\texttt{ruess@csl.sri.com}}}

\date{}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}\label{sec:intro}

ICS (Integrated Canonizer and Solver) is a
decision procedure developed at SRI International.
It efficiently decides formulas in a useful combination
of theories, and it provides an API that makes
it suitable for use in applications with highly dynamic
environments such as proof search or symbolic simulation.

The theory decided by ICS is a quantifier-free,
first-order theory of equality with terms built from
  \begin{itemize}
  \item uninterpreted function symbols,
  \item arithmetic operators including inequalities and number predicates,
  \item tupling operators and tuple projection,
  \item S-expressions,
  \item array lookup and update,
  \item operators on fixed-sized bitvectors.
  \end{itemize}
This theory is particularly interesting for many applications in the realm
of software and hardware verification.  Combinations of a multitude
of datatypes occur naturally in system specifications and the use of
uninterpreted function symbols has proven to be essential
for many real-world verifications.

The core of ICS is a congruence closure procedure~\cite{RuessShankar2001,ShankarRuess2002}
for the theory of equality and disequality with both uninterpreted and
interpreted function symbols.  The concepts of canonization and solving
have been extended to include inequalities over linear arithmetic
terms. The theory supported by ICS currently includes:
  \begin{itemize}
  \item The usual propositional constants {\tt true}, {\tt false}.
  \item Equality ({\tt =}) and disequality ({\tt /=})\@.
  \item Rational constants and the arithmetic
        operators {\tt +}, {\tt *}, {\tt -}\@;
        multiplication is restricted to
        multiplication by constants.
        Arithmetic predicates include an integer test and
        the usual inequalities {\tt <}, {\tt <=}, {\tt >}, {\tt >=}\@.
  \item Lookup {\tt $a$[$x$]} and update {\tt $a$[$x$:=$t$]}
        operations for arrays $a$\@.
  \item Fixed-sized bitvectors including constants such as {\tt 0b101},
        concatenation ({\tt conc[3,4]($b_1$,$b_2$)}),
        extraction ({\tt $b$[$i$:$j$]}), bit-wise operations
        like bit-wise conjunction  ({\tt $b_1$ \&\& $b_2$}),
        and built-in arithmetic relations such as {\tt add($b_1$,$b_2$,$b$)}\@.
        This latter constraint encodes the fact that the sum of the unsigned
        interpretations of $b_1$ and $b_2$ equals the unsigned
        interpretation of $b$.  Fixed-sized bitvectors are
        decided using the techniques described in~\cite{Moeller98:FMCAD}\@.
  \end{itemize}
ICS is capable of deciding sequents such as
  \begin{itemize}
  \item {\tt x+2 = y |- f(a[x:=3][y-2]) = f(y-x+1)}
  \item {\tt f(y-1)-1 = y+1, f(x)+1 = x-1, x+1 = y |- false}
  \item {\tt f(f(x)-f(y)) /= f(z),  y <= x, y >= x+z, z >= 0 |- false}
  \end{itemize}
These formulas contain uninterpreted function symbols
such as {\tt f} and interpreted symbols drawn from the theories of
arithmetic and the functional arrays.  The list of
interpreted theories above is open-ended in the sense that new
theories can be added to ICS as long as they are canonizable and
algebraically solvable. The modular design of ICS---both the
underlying algorithms and their implementation---supports such
extensions.

One of the main problems in employing decision procedures
effectively is due to the fact that verification conditions
usually depend on large contexts.  In addition, these
contexts change frequently in applications such as
symbolic simulation or backtracking proof search.
Consequently, decision procedure systems that
are effective in these domains must not only be able to
build up contexts incrementally but they must
also support efficiently switching between a multitude
of contexts.  ICS meets these criteria in that all of its
main algorithm work incrementally and the data
structures for representing contexts are persistent,
that is, operations on data structures do not alter the
previous values of data and {\em undo} operations
are therefore basically for free.

ICS is implemented in \textsf{Ocaml}~\cite{ObjectiveCaml},
which offers satisfactory run-time performance,
efficient garbage collection, and interfaces well with other
languages like C\@.  The implementation of ICS is based on optimization
techniques such as hash-consing~\cite{JCF2000}
and efficient data structures like Patricia trees~\cite{OkasakiGill98}
for representing sets and maps efficiently.

There is a well-defined API for manipulating ICS terms, asserting
formulas to the current database, switching between databases,
and functions for canonizing terms.
% and there is a functional and an imperative API\@.
This API is packaged as a C library, an \textsf{Ocaml} module,
and a CommonLisp interface. The C library API, for example, has been
used to connect ICS with PVS~\cite{PVS}\@, and both an interaction and
a batch processing capability have been built using this API\@.

Using ICS as the underlying decision procedure of PVS, we
experience speed-ups of several orders of magnitude (compared
with the PVS default decision procedures) for selected problems.
and for typical problems we are usually able to process several
thousand theorems every second.
The efficiency and scalability of ICS in processing formulas,
the richness of its API, and its ability for fast context-switching
should make it possible to use it as a black box for discharging
verification conditions not only in a theorem proving context
but also in a multitude of applications like static analysis,
abstract interpretation, extended type checking,
symbolic simulation, model checking, or compiler
optimization.

\subsection{Availability}

For academic, non-commercial use ICS is available free of charge under a 
license agreement with SRI.  ICS is also an integral part of PVS 3.0\@.
The complete sources and documentation of ICS are available at
  \begin{center}
  \url{www.icansolve.com}
  \end{center}
There one can also find the ICS license.


\subsection{Organization}

This document describes the interfaces and implementation
aspects of the ICS decision procedures.  The various modules of 
the implementation are not presented in
topological order with respect to their inter-dependencies, but
rather in a more logical order. However, it may help to have in mind
the graph of dependencies, which is the following:

%BEGIN LATEX
\input{epsf}
\epsfxsize=15cm
\begin{center}
\epsfbox{./dep.ps}
\end{center}
%END LATEX
%HEVEA\imgsrc{./dep.gif}


\section{Installation}\label{sec:installation}

\paragraph{Distribution.}
The file \texttt{ics.tar.gz} can be downlowded from \url{www.icansolve.com}.
Unpack this file using
  \begin{verbatim}
  > zcat ics.tar.gz | tar xvf -
  \end{verbatim}
This creates a directory \texttt{./ics} with the following files
and directory.\\
  \begin{tabular}{lcl}
   \texttt{Makefile.in}  & : & Template for generating \texttt{Makefile}.  \\
   \texttt{fm-license.in} & : & Noncommercial license. \\
   \texttt{bin/} & : & Binaries \\
   \texttt{configure} & : & Configuration script \\
   \texttt{lib/} & : & Archives and shared object files  \\
   \texttt{tests/} & : & Various benchmarks  \\
   \texttt{README} & : & Short installation guide  \\
   \texttt{doc/} & : & Documentation \\
   \texttt{obj/} & : & Object files \\
   \texttt{src/} & : & Source files \\
   \texttt{ics/} & : & Shell script for invoking ICS interactor\\
  \end{tabular}

The latest version of ICS can be obtained by using the
CVS checkout command
  \begin{verbatim}
  > cvs co ics -d $CVS_root
  \end{verbatim} % $
where \texttt{CVS\_root} is set to
  \begin{verbatim}
  /project/pvs2/cvsroot
  \end{verbatim}

\paragraph{Requirements.}
ICS is written mainly in Ocaml, and it uses uses arbitrary
precision rational numbers from the GNU multi-precision library (GMP)\@.
To compile ICS one needs to install:
  \begin{itemize}
  \item The \textsf{autoconf} package is freely available
        at \url{http://www.gnu.org/software/autoconf/}\@.
  \item \textsf{Ocaml} version 3.04 or later.
        Freely available at \url{http://caml.inria.fr}\@.
  \item \textsf{GNU MP} version 3.0 or later. This package is
        freely available at \url{http://www.swox.com/gmp/}\@.
  \end{itemize}
So far, we have only compiled \textsf{ICS} on \textsf{Linux Redhat 6.0},
but it should be possible to compile it on a wide range of
machines and operating systems.

\paragraph{Installation.}
A configuration \texttt{./configure} is generated from
\texttt{./configure.in} in the ICS home directory using
  \begin{verbatim}
  > autoconf
  \end{verbatim}
The configuration script generates a \texttt{Makefile} from the
\texttt{Makefile.in}. 
  \begin{verbatim}
  > ./configure [--with-gmp=/path/to/gmp]
  \end{verbatim}
Then, {\tt make} compiles ICS on your machine.
  \begin{verbatim}
  > make
  \end{verbatim}
Binaries are placed in \texttt{./bin/\$(ARCH)/} and
the libraries in {\tt ./lib/\$(ARCH)/}, where \texttt{ARCH}
is the architecture guessed by the configuration script.
The build directory is {\tt ./obj/\$(ARCH)/}, and the generated
binary and byte code are put in \texttt{./bin/\$(ARCH)/}.




\section{The ICS interactor}\label{sec:interactor}

The interactor permits to process formulas interactively and to explore
the database.  We give an overview of the capabilities of ICS
using various little examples.

The interactor is started with \texttt{./ics} in the ICS home directory.
\begin{verbatim}
% ics
ICS interpreter. Copyright (c) 2001 SRI International.

> 
\end{verbatim}
The `\texttt{>}' is the prompt and ICS is ready to interpret your commands.




\subsection{The Command Language}

The ICS command language realizes a {\em ask/tell} interface to
a context consisting of known facts. When invoking the interactor, 
this context is empty.

\paragraph{Asserting facts.}
  \begin{center}
  \texttt{assert} \atom \texttt{.}
  \end{center}
An $\atom$ is asserted to the current context using the
\texttt{assert} command. There are three possible outcomes:
  \begin{enumerate}
  \item  $\atom$ is inconsistent with respect to the current context.
         In this case, \texttt{assert} leaves the current context
         unchanged and outputs \texttt{Unsat.} on the standard
         output.
  \item  $\atom$ is valid in the current context. Again, the
         the current context is left, and now \texttt{Valid.}
         is output.
  \item  Otherwise, in case $\atom$ is satisfiable but not valid,
         the context is modified to include new information obtained
         from $\atom$.
  \end{enumerate}


\paragraph{Resetting.}
  \begin{center}
  \texttt{reset} \texttt{.}
  \end{center}
Reinitializes all internal data structures including
setting the current logical context to the empty context.

\paragraph{Clearing current logical context.}
  \begin{center}
  \texttt{forget} \texttt{.}
  \end{center}
Resets the current logical context to the empty 
context. In contrast to \texttt{reset}, all other
ICS data structures are left unchanged.


\paragraph{Sigmatization.}
  \begin{center}
  \texttt{sigma} (\term | \atom) \texttt{.}
  \end{center}
Computes the normal form of a term or an atom using
theory-specific canonizers for terms in interpreted
theories and some builtin simplifications for 
uninterpreted terms. This command leaves the 
current state unchanged.

\paragraph{Canonization.}
  \begin{center}
  \texttt{can} (\term | \atom) \texttt{.}
  \end{center}
For a term \texttt{t}, \texttt{can t} returns a
variable, which is a canonical representative of 
\texttt{t}.

For an atom \texttt{a}, \texttt{can a} returns a semicanonical 
form which reduces to the atom \texttt{True} if [a] can be shown
to hold in the current context, and \texttt{False} if \texttt{a}
can be shown to be inconsistent.  Otherwise, an atom
[b] is returned which is equivalent to [a] in the current
context.

[can] might involve a state change in that renaming
variables of the form \texttt{v!i} are generated and equalities
\texttt{v!i = a'} for subterms of \texttt{a} are added to the
logical context.

\paragraph{Solving.}
  \begin{center}
  \texttt{solve} (\texttt{a} | \texttt{t} \texttt{bv}) \term \texttt{=} \term  \texttt{.}
  \end{center}
Theory-specific solver for input equality. Returns either a solved 
list of equalities with variables on the lhs which is equivalent
to the input equality or \texttt{Unsat.} if the input equality is
unsatisfiable. There are solvers for linear arithmetic (\texttt{a}), 
tuples (\texttt{t}), and bitvectors (\texttt{bv}).

\paragraph{Logical Context.}
  \begin{center}
  \texttt{ctxt}  \texttt{.}
  \end{center}
Return the set of atoms asserted in the current logical context.
These atoms are not necessarily in canonical form.

\paragraph{Variable Partitioning.}
  \begin{center}
  \texttt{partition}  \texttt{.}
  \end{center}
Returns the set of all known equalities between variables.

\paragraph{Solution sets.}
  \begin{center}
  \texttt{solution} (\texttt{u} | \texttt{a} | \texttt{t} \texttt{bv}) \texttt{.}
  \end{center}
Returns the solution set corresponding to the specified theory,
which consists of a set of equalities \texttt{x = a} with \texttt{x}
a variable and \texttt{a} a term built-up from variables and function
symbols in the specified theory.  Variables on the rhs might either be
external variables or fresh variables introduced by a theory-specific solver.
For all interpreted theories, that is, for all theories except for the 
uninterpreted theory \texttt{u}, the equations in a solved form are 
actually solved in that variables \texttt{x} on a rhs do not occur in any 
of the lhs. 

\paragraph{Finds in solution sets.}
  \begin{center}
  \texttt{find} (\texttt{u} | \texttt{a} | \texttt{t} \texttt{bv}) \term \texttt{.}
  \end{center}
If \texttt{x = t} is in the specified solution set (see command \texttt{solution}),
then \texttt{find . x} returns \texttt{t} and otherwise \texttt{x}.

\paragraph{Inverse Finds in solution sets.}
  \begin{center}
  \texttt{find} (\texttt{u} | \texttt{a} | \texttt{t} \texttt{bv}) \term \texttt{.}
  \end{center}
If \texttt{x = t} is in the specified solution set (see command \texttt{solution}),
then \texttt{inv . t} returns \texttt{x} and otherwise \texttt{Unsat.}\@.

\paragraph{Comparison.}
  \begin{center}
  \term \texttt{<<} \term \texttt{.}
  \end{center}
Syntactic comparison of two terms. \texttt{s << t } returns 
\texttt{Less} (\texttt{Equal}, \texttt{Greater}
if \texttt{s} is less (equal, greater) than \texttt{t} according
to the builtin term ordering.

\paragraph{Arithmetic Constraints.}
  \begin{center}
  \texttt{cnstrnt} \term \texttt{.}
  \end{center}
Compute an arithmetic constraint for the argument term in
the current context using abstract interpretation on intervals.
Returns \texttt{None.} if no such constraint could be deduced.

\paragraph{Disequalities.}
  \begin{center}
  \texttt{diseq} \term \texttt{.}
  \end{center}
Returns a list of variables known to be disequal in the
current context.

\paragraph{Displaying the context.}
  \begin{center}
  \texttt{show} \texttt{.}
  \end{center}
Displays the variable partitioning, theory-specific
solution sets, and disequality information. See also the 
commands \texttt{partition}, \texttt{solution}, and \texttt{diseq}\@.

\paragraph{Term Definition.}
  \begin{center}
  \texttt{def} \var \texttt{:=} \term \texttt{.}
  \end{center}
Extend the symbol table with a definition \var for term \term\@.
In such a context, variable \var is always expanded to \term.

\paragraph{Type Definition.}
  \begin{center}
  \texttt{type} \var \texttt{:=} \cnstrnt \texttt{.}
  \end{center}
Extend the symbol table with a definition \var for the
constraint \cnstrnt\@. In such a context, variable \var 
can always be used instead of the corresponding constraint.

\paragraph{Signature Declaration.}
  \begin{center}
  \texttt{sig} \var \texttt{:=} \texttt{bv[int]} \texttt{.}
  \end{center}
Declare a variable to be interpreted over the set of 
bitvectors of width \texttt{int}. This context information
is used for inferring parameters when applying infix bitvector
operators.

\paragraph{Symbol Table.}
  \begin{center}
  \texttt{symtab} \{\var\} \texttt{.}
  \end{center}
\texttt{symtab} display the current symbol table, and
\texttt{symtab}\ \var displays the symbol table entry
for \var.

\paragraph{Saving the current logical context.}
  \begin{center}
  \texttt{save} \{\var\} \texttt{.}
  \end{center}
Adding a symbol table entry for the current logical state.

\paragraph{Restoring logical contexts.}
  \begin{center}
  \texttt{restore} \{\var\} \texttt{.}
  \end{center}
Updating the current logical state to be the state
named by \var in the symbol table.

\paragraph{Removing symbol table entries}
  \begin{center}
  \texttt{remove} \{\var\} \texttt{.}
  \end{center}
Remove the symbol table entry corresponding to \var.

\paragraph{Verbose.}
  \begin{center}
  \texttt{verbose} \textit{int} \texttt{.}
  \end{center}
Determines the amount of trace information displayed on standard output.
The larger the argument the more information is output.

\paragraph{Garbage Collection.}
  \begin{center}
  \texttt{gc} \texttt{.}
  \end{center}
This command results in a logical context which is equivalent
to the current one but redundant variables are eliminated.

\paragraph{Debugging.}
  \begin{center}
  \texttt{drop} \texttt{.}
  \end{center}
The effect of this command is to fall back into the Ocaml
interactor when running bytecode; otherwise ICS is terminated.
This command is mainly for debugging purposes.

\paragraph{Exiting ICS.}
  \begin{center}
  \texttt{exit} \texttt{.}
  \end{center}
Exit the ICS interactor. Alternatively, \texttt{Ctrl-D} can
be used.


\section{Application Programming Interface}\label{sec:api}

Usually, the capabilites of ICS are not accessed through the interactor
but rather through its application programming interface.  Currently,
we support interfaces for C, Fortran, Lisp, and Ocaml.  We
first describe the Ocaml interface, since the interfaces for the
other programming languages are automatically generated from this one.

\subsection{Caml interface}

 \input{./literal/ics.mli}

\subsection{C Interface}

The API for the C programming language is generated automatically
from the Ocaml API described above. The generated C file can be found in
  \begin{verbatim}
  ./obj/$ARCH/ics_stub.c
  \end{verbatim}
% $
This file contains a C function declaration \texttt{ics\_xxx} for each of the interface
function \texttt{xxx} described above.  For example, the definition of
the function \texttt{ics\_mk\_var} for the \texttt{mk\_var} constructor is
given by the following C code.
  \begin{verbatim}
value* ics_mk_var(char* x1) {
  value* ics_mk_var(char* x1) {
  value* r = malloc(sizeof(value));
  register_global_root(r);
  *r = 1;
  *r = callback_exn(*ics_mk_var_rv,copy_string(x1));
  if (!Is_exception_result(*r)) { return r; };
  ocaml_error("ics_mk_var",format_caml_exception(Extract_exception(*r)));
  return (value*) 0;
}
 \end{verbatim}
These interface function translate C arguments to Ocaml values, call the
Ocaml function, and translate back the results. In addition, any Ocaml
exceptions are caught and handled by the \texttt{ocaml\_error} function.
Curried signatures of the Ocaml functions are uncurried, and list and
tuple arguments must be build using the constructors of the interface.
The handling of exceptions is determined by the function
\texttt{ocaml\_error}, which has to be provided by the application
programmer.

When using {\tt C++} the following declarations are needed to
use ICS.  First, declare a function {\tt ics\_caml\_startup} before
including {\tt ics.h}.\footnote{Within the {\tt extern "C"} directive,
the {\tt C++} compiler does not rename functions.}
\begin{verbatim}
extern "C" {
void ics_caml_startup(int full, char** argv);
#include<ics.h>
}
\end{verbatim}
Second, an application-dependent {\tt ics\_error} function
such as the one below has to be provided.
\begin{verbatim}
extern "C" {

void ics_error(char * funname, char * message) {
    cerr << "ICS error at " << funname << " : " << message << endl;
    exit(1);
}
}
\end{verbatim}
Third, before calling any ICS functionality, call {\tt ics\_caml\_startup}.
\begin{verbatim}
int main(int argc, char ** argv) {
    ics_caml_startup(1, argv);
    ...
}
\end{verbatim}
A minimal {\tt C++} program for calling ICS can be found in 
Figure~\ref{fig:hello-ics}. If this program is stored in a file
{\tt hello-ics.cpp}, then it can be compiled using
  \begin{verbatim} 
  g++ hello-ics.cpp -lics
  \end{verbatim}
Notice that {\tt LD\_LIBRARY\_PATH} variable should be such that
the shared object file {\tt libics.so} can be found in the linking
stage.

\begin{figure}[t]
\begin{verbatim}
#include<iostream.h>
extern "C" {
void ics_caml_startup(int full, char** argv);
#include<ics.h>
}

int main(int argc, char ** argv) {
    ics_caml_startup(1, argv);
    cout << "ICS: Hello World\n";
}


extern "C" {
void ics_error(char * funname, char * message) {
    cerr << "ICS error at " << funname << " : " << message << endl;
    exit(1);
}}
\end{verbatim}
\caption{Minimal setup for calling ICS.\label{fig:hello-ics}}
\end{figure}


\subsection{Lisp Interface}

The Lisp API for ICS builds on the C interface and uses the foreign
function interface of Allegro Common Lisp 6.0.  For each function
\texttt{xxx} in the API a foreign function declaration \texttt{ics\_xxx}
is generated.  These definitions are collected in the file
 \begin{verbatim}
  ./obj/$ARCH/ics.lisp
  \end{verbatim}
% $
The Lisp interface ensures that the Lisp and the Ocaml garbage collector
cooperate.

\section{Data Structures}\label{sec:terms}

Terms and atoms are the main syntactic categories of ICS,
where atoms are equalities or disequalities over terms
or interval constraints over terms.

\subsection{Term data structure}\label{subsec:terms}

A term is either a variable or an application of a function
symbol to a list of terms. 

\subsubsection{Function Symbols.}
  \input{./literal/sym.mli}
  \input{./literal/sym.ml}

  \subsubsection{Variables.}
  \input{./literal/var.mli}
  \input{./literal/var.ml}


  \subsubsection{Terms.}
  \input{./literal/term.mli}
  \input{./literal/term.ml}


 \subsection{Constraints}\label{sec:cnstrnts}
  Constraints consists of an interval and a set of 
  so-called exclusive numbers. 

 \subsubsection{Interval constraints}\label{subsec:interval}
  \input{./literal/endpoint.mli}
  \input{./literal/endpoint.ml}
  \input{./literal/interval.mli}
  \input{./literal/interval.ml}

 \subsubsection{Interval constraints with disequalities}\label{subsec:cnstrnts}
  \input{./literal/cnstrnt.mli}
  \input{./literal/cnstrnt.ml}

 \subsection{Atoms}\label{subsec:atoms}
   An atom is either an equality over terms, a disequality
   over terms, or a constraint for a term.
   \input{./literal/atom.mli}
   \input{./literal/atom.ml} 


\section{Theories}\label{sec:theories}
  ICS supports the theories of equality over uninterpreted
  function symbols and a collection of interpreted theories
  including arithmetic, tuples, and bitvectors.  For each
  function symbol in interpreted theories there is corresponding
  constructor function for building terms in a well-defined
  canonical form.  In addition, for certain uninterpreted
  function symbols there are builtin rewrite rules.  Solvers
  are only defined for interpreted theory.

\subsection{Theory of Uninterpreted Functions}\label{sec:uninterpreted}

  For some uninterpreted function symbols, simplifying
  rewrites are builtin into the canonization process.

  \subsubsection{Uninterpreted Application}
    \input{./literal/app.mli}
    \input{./literal/app.ml}

  \subsubsection{Builtin Simplifications}
    \input{./literal/builtin.mli}
    \input{./literal/builtin.ml}


 \subsection{Theory of Arithmetic}\label{subsec:arithmetic}

    \input{./literal/arith.mli}
    \input{./literal/arith.ml}


 \subsection{Theory of Tuple}\label{subsec:tuples}

   \input{./literal/tuple.mli}

   \input{./literal/tuple.ml}


 \subsection{Theory of Propositional Constants}\label{subsec:propositional}

 \input{./literal/boolean.mli}

 \input{./literal/boolean.ml}


 \subsection{Theory of Fixsized Bitvectors}\label{subsec:bv}
  \input{./literal/bitvector.mli}
  \input{./literal/bitvector.ml}


\section{Congruence Closure}\label{sec:cc}

 \input{./literal/cc.mli}
 \input{./literal/cc.ml} 

\section{Constraints on Variables}
  \input{./literal/c.mli}
  \input{./literal/c.ml}

\section{Disequalities}
  \input{./literal/d.mli}
  \input{./literal/d.ml}



\section{Interpreted Solutions Sets}\label{sec:cc}

 \input{./literal/th.mli}
 \input{./literal/th.ml}
 
 \subsection{Arithmetic}
  An arithmetic context consists of an arithmetic
  solution set and constraints on slack variables.
  \input{./literal/a.mli}
  \input{./literal/a.ml}

 \subsection{Tuples}
  \input{./literal/t.mli}
  \input{./literal/t.ml}

 \subsection{Booleans}
  \input{./literal/b.mli}
  \input{./literal/b.ml}

 \subsection{Bitvectors}
  \input{./literal/bv.mli}
  \input{./literal/bv.ml}

 \subsection{Solution Sets}
  \input{./literal/subst.mli}
  \input{./literal/subst.ml}

\section{Shostak's Combination}
  \input{./literal/theories.mli}  
  \input{./literal/theories.ml} 
  \input{./literal/shostak.mli}  
  \input{./literal/shostak.ml} 

\section{Imperative Interface}
  \input{./literal/istate.mli}  
  \input{./literal/istate.ml} 
  \input{./literal/symtab.mli}  
  \input{./literal/symtab.ml}

\section{Variable Equalities}
  \input{./literal/veq.mli}  
  \input{./literal/veq.ml} 
  \input{./literal/veqs.mli}  
  \input{./literal/veqs.ml} 


\section{Tools and Support}\label{sec:misc}

  \subsection{Tools}\label{subsec:tools}

  This chapter describes the utility modules. The module \textit{Tools}
  contained utility functions used in the implementation. The modules
  \textit{Lexer} and \textit{Parser} provide parsers for terms,
  equations, commands, etc. (we only give the interface for module
  \textit{Lexer}). The module \textit{Test} is a tiny toplevel
  to test the implementation. It allows the user to test the
  canonization and solver functions, and the algorithm.

  \input{./literal/tools.mli}
  \input{./literal/tools.ml}

  \subsection{Arbitrary Precision Arithmetic}\label{sec:apa}
   \input{./literal/mpa.mli}
   \input{./literal/mpa.ml}

  \subsection{Extended Arbitrary Precision Arithmetic}\label{sec:apa}
   \input{./literal/mpa.mli}
   \input{./literal/mpa.ml}

  \subsection{Pretty-Printer}\label{subsec:pretty}
  \input{./literal/pretty.mli}
  \input{./literal/pretty.ml}

  \subsection{Exceptions}\label{subsec:exceptions}

   \input{./literal/exc.mli}
   \input{./literal/exc.ml}

  \subsection{Binary Relations}\label{subsec:binrel}

   \input{./literal/binrel.mli}
   \input{./literal/binrel.ml}

  \subsection{Hash Consing}\label{subsec:hashcons}

  \input{./literal/hashcons.mli}
  \input{./literal/hashcons.ml}
 
  \subsection{Tracing}\label{subsec:trace}

   \input{./literal/trace.mli}
   \input{./literal/trace.ml}

\section{ICS Interactor}\label{sec:interpreter}
  \input{./literal/main.ml}

\section{Parsing}\label{sec:parsing}
  \subsection{Lexer}\label{subsec:lexer}
 
  \verbatiminput{../src/lexer.mll}

  \subsection{Parser}\label{subsec:parser}
 
  \verbatiminput{../src/parser.mly}



\vspace{10mm}
{\bf Acknowledgements.}
The algorithms and data structures underlying ICS have been
developed by N. Shankar and Harald Rue{\ss}\@. The core ICS code is
by  Harald Rue{\ss} and Jean-Christophe Filli{\^a}tre, and the Lisp
interface has been developed by Sam Owre, Harald Rue{\ss}, and
Jean-Christophe Filli{\^a}tre. The GMP ocaml interface was originally
written by David Monniaux, and adjusted for use with \texttt{ocaml 3.00} by
Jean-Christophe Filli{\^a}tre.

 This document has been automatically produced
from the source code using the literate programming tool \textsf{ocamlweb}%
\footnote{\textsf{Objective Caml} and
  \textsf{ocamlweb} are both freely available, respectively at
  \textsf{http://caml.inria.fr} and
  \textsf{http://www.lri.fr/\~{}filliatr/ocamlweb}}.


\bibliographystyle{alpha}
\addcontentsline{toc}{section}{References}
\bibliography{./biblio}

\end{document}








