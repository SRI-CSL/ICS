<html>

<head>
<title>ICS---Introduction</title>
</head>

<base href="http://www.icansolve.com">
<body bgcolor="#ffffff">

<font face="ariel,helvetica" size="+3"><b>
<center>
       <img src="/images/csl_banner1.jpg" width=50> Introduction
 </center>
</b></font>
<hr noshade>

Decision procedures are at the core of many
industrial-strength verification systems such as
<a href="http://www.cs.utexas.edu/users/moore/acl2/">ACL2</a>,
<a href="http://pvs.csl.sri.com">PVS</a>,
<a href="http://rodin.stanford.edu/">STeP</a>, or
<a href="http://www.ora.on.ca/z-eves/welcome.html">Z/Eves</a>.
Effective use of decision procedures
in these verification systems require the management of
large assertional contexts.  Many decision procedure,
however, are typically used in a fire-and-forget
environment, and lack an appropriate API for managing
contexts and efficiently switching between contexts.

<p>
ICS (Integrated Canonizer and Solver) is a
decision procedure developed at SRI International.
It is based on well-developed theory,
it efficiently decides formulas in a useful combination
of theories, and it provides an API that makes
it suitable for use in applications with highly dynamic
environments such as proof search or symbolic simulation.

<p>
The theory decided by ICS is a quantifier-free,
first-order theory with uninterpreted function symbols and a
rich combination of datatype theories including arithmetic, arrays, sets,
and bit-vectors.  This theory is particularly interesting
for many applications in the realm of software and
hardware verification.  Combinations of a multitude of datatypes occur
naturally in system specifications and the use of uninterpreted
function symbols has proven to be essential
for many real-world verifications.

<p>
The core of ICS is a recently developed congruence closure
procedure for the theory of equality and disequality with
both uninterpreted and interpreted function symbols. The concepts
of canonization and solving have been extended to include inequalities
over linear arithmetic terms and propositional logic.
The theory currently includes:
  <ul>
  <li> The usual propositional constants and connectives.</li>
  <li> Equality and disequality.</li>
  <li> Rational constants and the arithmetic
       operators, where multiplication is restricted to
       multiplication by constants.
       Arithmetic predicates include an integer test and
       the usual inequalities.</lil>
  <li> Lookup and update
        operations for a functional array.</li>
  <li> The constant sets and set operations such as union, intersection,
        or complement.</li>
  <li> Fixed-sized bitvectors including constants,
        concatenation,
        extraction, and bit-wise operations
        such  bit-wise conjunction,
        and built-in arithmetic relations such as addition.</li>
  </ul>
ICS is capable of deciding formulas such as
  <ul>
  <li><tt>x+2 = y => f(a[x:=3][y-2]) = f(y-x+1)</tt> </li>
  <li><tt>f(y-1)-1 = y+1 &  f(x)+1 = x-1 & x+1 = y => false</tt> </li>
  <li><tt>f(f(x)-f(y)) /= f(z) &  y <= x & y >= x+z & z >= 0 => false</tt></li>
  </ul>
These formulas contain uninterpreted function symbols
such as <tt>f</tt> and interpreted symbols drawn from the theories of
arithmetic and the functional arrays.  The list of
interpreted theories above is open-ended in the sense that new
theories can be added to ICS as long as they are canonizable and
algebraically solvable. The modular design of ICS---both the
underlying algorithms and their implementation---supports such
extensions.

<p>
Verification conditions are usually proved within
the context of a large number of assertions derived from
the antecedents of implications, conditional tests, and
predicate subtype constraints.  These contexts must be changed
in an incremental manner when assertions are either added or
removed.  Through the use of functional data structures, ICS allows
contexts to be incrementally enriched in a side-effect-free manner.

<p>
ICS is implemented in
<a href="http://caml.inria.fr/ocaml/">Ocaml</a>,
which offers satisfactory run-time performance,
efficient garbage collection, and interfaces well with other
languages like C.  The implementation of ICS is based on optimization
techniques such as hash-consing and efficient data structures such as
Patricia trees for representing sets and maps efficiently.  ICS uses arbitrary
precision rational numbers from the GNU multi-precision library
<a href="http://www.gnu.org/software/gmp/gmp.html">GMP</a>.

<p>
There is a well-defined API for manipulating ICS terms, asserting
formulas to the current database, switching between databases,
and functions for canonizing terms.
% and there is a functional and an imperative API.
This API is packaged as a C library, an Ocaml module,
and a CommonLisp interface. The C library API, for example, has been
used to connect ICS with PVS, and both an interaction and
a batch processing capability have been built using this API.

<p>
Consider, for example, processing
<tt>f(y-1)-1 = y+1</tt>,
<tt>f(x)+1 = x-1</tt>, and <tt>x+1 = y</tt>
from left-to-right using the interactive mode of ICS.
  <pre>
  % ics
  ICS interpreter. Copyright (c) 2001 SRI International.
  Ctrl-d to exit.

  >  assert f(y - 1) - 1 = y + 1.
  </pre>
This equation is asserted in its solved form as
<tt>y = -2 + f(-1 + y)</tt>. This equation is indeed considered
to be in solved form, since <tt>y</tt> on the right-hand side occurs
only in the scope of the uninterpreted <tt>f</tt>. Terms
in the database are partitioned
into equivalence classes, and the canonical representative of any
term t with respect to this partition is represented by <tt>can(t)</tt>;
for example:
  <pre>
  > can -1 + y.
  -3 + f(-1 + y)
  </pre>

<p>
It can be shown that <tt>can(t1)</tt> is identical to <tt>can(t2)</tt>
iff the equality <tt>t1 = t2</tt> is derivable in the current context.
Now, the second equation is processed
  <pre>
  > assert f(x) + 1 = x - 1.
  </pre>
by canonizing it to <tt>1 + f(x) = -1 + </tt>x and solving this
equation as <tt>x = 2 + f(x)</tt>. Finally, <tt>can x + 1</tt> yields
<tt>3 + f(x)</tt> and <tt>can y</tt> is <tt>-2 + f(-1 + y)</tt>. Thus,
the third equation is solved as <tt>f(x) = -5 + f(-1 + y)</tt>.
Since <tt>f(x) = f(-1 + y)</tt>, using <tt>x = -1 + y</tt> and congruence,
there is a contradiction <tt>-5 = 0</tt>.
Indeed, ICS detects this inconsistency, when given the assertion
below.
  <pre>
   > assert x + 1 = y.
  Inconsistent!
  </pre>

<p>
Using ICS as the underlying decision procedure of PVS, we
experience speed-ups of several orders of magnitude (compared
with the PVS default decision procedures) for selected problems.
and for typical problems we are usually able to process several
thousand theorems every second.
The efficiency and scalability of ICS in processing formulas,
the richness of its API, and its ability for fast context-switching
should make it possible to use it as a black box for discharging
verification conditions not only in a theorem proving context
but also in a multitude of applications like static analysis,
abstract interpretation, extended type checking,
symbolic simulation, model checking, or compiler
optimization. ICS will be available free of charge under the PVS license.
It will also be the default decision procedure of the upcoming release
of PVS 3.0.


<p>
<hr>

<a href="index.html"><img src="back.gif"> 
Back to the main ICS homepage</a>

<hr noshade>
<font size="-1"><i>Last updated April 20 2001 by 
<a href="mailto:ruess@csl.sri.com">Harald Rue&szlig;</a></i><font size="+1">
<img src="http://www.csl.sri.com/cgi-ics/count?people" border=0 height=1 width=1>
</body>
</html>
